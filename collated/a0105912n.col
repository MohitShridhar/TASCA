//@author: a0105912n



	/**
	 * origin: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\gui\BufferedGraphics.java
	 */

public class BufferedGraphics {
    
    private static final String FILEPATH_KEYWORD_ITEM_BACKGROUND = "/GUI Graphics/Keyword Item Background.png";
    private static final String FILEPATH_SCROLL_THUMB = "/GUI Graphics/Scroll Thumb.png";
    private static final String FILEPATH_SCROLL_TRACK = "/GUI Graphics/Scroll Track.png";
    private static final String FILEPATH_UI_BACKGROUND = "/GUI Graphics/Task Item Background.gif";
    private static final String FILEPATH_INFO_ICON = "/GUI Graphics/Info Icon.png";
    private static final String FILEPATH_DATE_TOGGLE_ICON = "/GUI Graphics/Time Display Icon.png";
    private static final String FILEPATH_LOW_PRIORITY_ICON = "/GUI Graphics/Task Item Low Pri.png";
    private static final String FILEPATH_MEDIUM_PRIORITY_ICON = "/GUI Graphics/Task Item Med Pri.png";
    private static final String FILEPATH_HIGH_PRIORITY_ICON = "/GUI Graphics/Task Item High Pri.png";
    private static final String FILEPATH_DELETE_ICON = "/GUI Graphics/Delete Icon.png";
    private static final String FILEPATH_REMINDER_ICON = "/GUI Graphics/Task Item Reminder Icon.png";
    private static final String FILEPATH_UNCHECKED = "/GUI Graphics/Unchecked Icon.png";
    private static final String FILEPATH_CHECK_MARK = "/GUI Graphics/Task Item Check Mark.gif";
    
    public final static Logger logger = Controller.getLogger();
    public static final String MESSAGE_GRAPHICS_LOAD_FAILED = "Could not load important graphics";
    
    private ImageIcon checkMark;
    private ImageIcon reminderIcon;
    private ImageIcon highPri;
    private ImageIcon medPri;
    private ImageIcon lowPri;
    private ImageIcon background;
    private ImageIcon unchecked;
    private ImageIcon delete;
    private ImageIcon date;
    private ImageIcon info;
    private ImageIcon keywordItem;
    private Image track;
    private Image thumb;
    
    public BufferedGraphics() {
	
	try {
	    bufferTaskItemUi();
	    loadMainInterfaceUi();
	    
	    bufferPriorityIcons();
	    bufferTimePropertyIcons();
	    
	    bufferScrollBarUi();
	    bufferSettingsPaneUi();
	   
	} catch (IOException e) {
	    logger.log(Level.SEVERE, MESSAGE_GRAPHICS_LOAD_FAILED + e.getStackTrace());
	    Assert.fail(MESSAGE_GRAPHICS_LOAD_FAILED);
	}
	
    }

    public void loadMainInterfaceUi() throws IOException {
	setBackground(new ImageIcon(ImageIO.read(MainInterface.class.getResource(FILEPATH_UI_BACKGROUND))));
    }

    public void bufferTaskItemUi() throws IOException {
	setCheckMark(new ImageIcon(ImageIO.read((MainInterface.class.getResource(FILEPATH_CHECK_MARK)))));
	setUnchecked(new ImageIcon(ImageIO.read((MainInterface.class.getResource(FILEPATH_UNCHECKED)))));
	setReminderIcon(new ImageIcon(ImageIO.read((MainInterface.class.getResource(FILEPATH_REMINDER_ICON)))));
	setDelete(new ImageIcon(ImageIO.read((MainInterface.class.getResource(FILEPATH_DELETE_ICON)))));
    }

    public void bufferSettingsPaneUi() throws IOException {
	setKeywordItem(new ImageIcon(ImageIO.read(MainInterface.class.getResource(FILEPATH_KEYWORD_ITEM_BACKGROUND))));
    }

    public void bufferTimePropertyIcons() throws IOException {
	setDate(new ImageIcon(ImageIO.read(MainInterface.class.getResource(FILEPATH_DATE_TOGGLE_ICON))));
	setInfo(new ImageIcon(ImageIO.read(MainInterface.class.getResource(FILEPATH_INFO_ICON))));
    }

    public void bufferScrollBarUi() throws IOException {
	setTrack(ImageIO.read(MainInterface.class.getResource(FILEPATH_SCROLL_TRACK)));
	setThumb(ImageIO.read(MainInterface.class.getResource(FILEPATH_SCROLL_THUMB)));
    }

    public void bufferPriorityIcons() throws IOException {
	setHighPri(new ImageIcon(ImageIO.read((MainInterface.class.getResource(FILEPATH_HIGH_PRIORITY_ICON)))));
	setMedPri(new ImageIcon(ImageIO.read((MainInterface.class.getResource(FILEPATH_MEDIUM_PRIORITY_ICON)))));
	setLowPri(new ImageIcon(ImageIO.read((MainInterface.class.getResource(FILEPATH_LOW_PRIORITY_ICON)))));
    }

    public ImageIcon getCheckMark() {
	return checkMark;
    }

    private void setCheckMark(ImageIcon checkMark) {
	this.checkMark = checkMark;
    }

    public ImageIcon getReminderIcon() {
	return reminderIcon;
    }

    private void setReminderIcon(ImageIcon reminderIcon) {
	this.reminderIcon = reminderIcon;
    }

    public ImageIcon getHighPri() {
	return highPri;
    }

    private void setHighPri(ImageIcon highPri) {
	this.highPri = highPri;
    }

    public ImageIcon getMedPri() {
	return medPri;
    }

    private void setMedPri(ImageIcon medPri) {
	this.medPri = medPri;
    }

    public ImageIcon getLowPri() {
	return lowPri;
    }

    private void setLowPri(ImageIcon lowPri) {
	this.lowPri = lowPri;
    }

    public ImageIcon getBackground() {
	return background;
    }

    private void setBackground(ImageIcon background) {
	this.background = background;
    }

    public ImageIcon getUnchecked() {
	return unchecked;
    }

    private void setUnchecked(ImageIcon unchecked) {
	this.unchecked = unchecked;
    }

    public ImageIcon getDelete() {
	return delete;
    }

    private void setDelete(ImageIcon delete) {
	this.delete = delete;
    }

    public ImageIcon getDate() {
	return date;
    }

    private void setDate(ImageIcon date) {
	this.date = date;
    }

    public ImageIcon getInfo() {
	return info;
    }

    private void setInfo(ImageIcon info) {
	this.info = info;
    }

    public ImageIcon getKeywordItem() {
	return keywordItem;
    }

    private void setKeywordItem(ImageIcon keywordItem) {
	this.keywordItem = keywordItem;
    }

    public Image getTrack() {
	return track;
    }

    private void setTrack(Image track) {
	this.track = track;
    }

    public Image getThumb() {
	return thumb;
    }

    private void setThumb(Image thumb) {
	this.thumb = thumb;
    }
    
}

	// End of segment: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\gui\BufferedGraphics.java





	/**
	 * origin: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\gui\FolderNameField.java
	 */

public class FolderNameField extends JTextField {
    

    private static final int MAX_COLUMNS = 10;
    private static final Color COLOR_UI_BACKGROUND = Color.decode("#443e3e");
    private static final long serialVersionUID = 1L;

    public FolderNameField(Rectangle bounds, String name, JFrame mainInterfaceFrame) {
	super();
	
	loadSettings(bounds, name);
	
	mainInterfaceFrame.getContentPane().add(this);
    }

    public void loadSettings(Rectangle bounds, String name) {
	
	setFont(MainInterface.latoReg15); 
	setForeground(Color.WHITE);
	setBackground(COLOR_UI_BACKGROUND);
	setHorizontalAlignment(SwingConstants.CENTER);
	setBounds(bounds);
	
	setText(name);
	setCaretColor(Color.WHITE);
	
	setColumns(MAX_COLUMNS);
    }
}

	// End of segment: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\gui\FolderNameField.java





	/**
	 * origin: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\gui\FolderTab.java
	 */

public class FolderTab extends JLayeredPane {
    
    public final static Logger logger = Controller.getLogger();
    
    private static final int INVALID_FOLDER_REF = -1;
    private static final int NUM_FOLDERS = 5;
    
    private static final String FILEPATH_IMAGE_CLICKED = "/GUI Graphics/Tab Clicked.gif";
    private static final String FILEPATH_IMAGE_NOT_CLICKED = "/GUI Graphics/Tab NotClicked.gif";
    
    private static final Dimension DIMENSIONS_FOLDER_TAB = new Dimension(177, 28);
    
    private static final Border SETTINGS_EMPTY_BORDER = BorderFactory.createEmptyBorder(0,0,0,0);
    private static final long serialVersionUID = 1L;

    private static ImageIcon tabNotClickedIcon, tabClickedIcon;
    private JButton folderBtn;
    	
    private FolderName folderName = FolderName.DEFAULT;
    
    private static Map<FolderName, FolderTab> folderNameMap = new HashMap<FolderName, FolderTab>();
    private JLabel folderLabel;
    
    static {
	
	try {
	    tabNotClickedIcon = new ImageIcon(ImageIO.read((MainInterface.class.getResource(FILEPATH_IMAGE_NOT_CLICKED))));
	    tabClickedIcon = new ImageIcon(ImageIO.read((MainInterface.class.getResource(FILEPATH_IMAGE_CLICKED))));
	} catch (IOException e) {
	    logger.log(Level.SEVERE, BufferedGraphics.MESSAGE_GRAPHICS_LOAD_FAILED + e.getStackTrace());
	    Assert.fail(BufferedGraphics.MESSAGE_GRAPHICS_LOAD_FAILED);
	}
    }
    
    
    public FolderTab(FolderName folderName, Point location, String folderLabelText) {
	
	loadTabSettings(location);
	linkMainInterfaceComponents(folderName);
	
	addFolderLabel(folderLabelText);
	addFolderButton(folderName);
	
    }

    private void addFolderButton(FolderName folderName) {
	
	folderBtn = new JButton("");
	folderBtn.setSize(DIMENSIONS_FOLDER_TAB);
	folderBtn.setOpaque(false);
	folderBtn.setFocusPainted(false);
	folderBtn.setBorderPainted(false);
	folderBtn.setContentAreaFilled(false);
	folderBtn.setBorder(SETTINGS_EMPTY_BORDER);
	
	attachMouseListener();
	initTabState(folderName);
	
	add(folderBtn);
    }

    private void attachMouseListener() {
	folderBtn.addActionListener(new ActionListener() {
	    public void actionPerformed(ActionEvent e) {
		folderActivate();
	    }
	});
    }

    private void initTabState(FolderName folderName) {
	if (MainInterface.getDefaultFolder() == folderName) {
	    folderBtn.setIcon(tabClickedIcon);
	} else {
	    folderBtn.setIcon(tabNotClickedIcon);
	}
    }

    private void addFolderLabel(String folderLabelText) {
	folderLabel = new JLabel();
	folderLabel.setHorizontalAlignment(SwingConstants.CENTER);
	folderLabel.setFont(MainInterface.latoReg14); 
	folderLabel.setForeground(Color.WHITE);
	folderLabel.setSize(DIMENSIONS_FOLDER_TAB);
	folderLabel.setText(folderLabelText);
	add(folderLabel);
    }

    private void linkMainInterfaceComponents(FolderName folderName) {
	this.folderName = folderName;
	folderNameMap.put(folderName, this);
    }

    private void loadTabSettings(Point location) {
	this.setBorder(SETTINGS_EMPTY_BORDER);
	this.setLocation(location);
	this.setSize(DIMENSIONS_FOLDER_TAB);
    }

    public void folderActivate() {
	
	updateFolderReferences();
	
	if (MainInterface.getCurrFolder() != MainInterface.getPrevFolder()) {
	    executeTabSwitch();
	    MainInterface.updateTaskDisplay();
	}

    }

    private void executeTabSwitch() {
	
	folderBtn.setIcon(tabClickedIcon);
	folderNameMap.get(MainInterface.getPrevFolder()).clearTab();
	
    }
    
    private void updateFolderReferences() {
	
	MainInterface.setCycleRef(searchFolderRef(MainInterface.getFolderCycle(), folderName));
	MainInterface.setPrevFolder(MainInterface.getCurrFolder());
	MainInterface.setCurrFolder(folderName);
	
    }
    
    private static int searchFolderRef(FolderName[] folderCycle, FolderName currFolder) {
	
	int cycleRef = INVALID_FOLDER_REF;
	
	for (cycleRef=0; cycleRef<NUM_FOLDERS; cycleRef++) {
	    if (folderCycle[cycleRef] == currFolder) {
		return cycleRef;
	    }
	}
	
	assert(cycleRef != INVALID_FOLDER_REF);
	
	return cycleRef;
    }
    
    private void clearTab() {
	folderBtn.setIcon(tabNotClickedIcon);
    }
    
    public void setLabelText(String labelText) {
	folderLabel.setText(labelText);
    }
    
    public static void gotoFolder(FolderName nextFolder) {
	folderNameMap.get(nextFolder).folderActivate();
    }
    
 }

	// End of segment: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\gui\FolderTab.java





	/**
	 * origin: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\gui\InputColorFilter.java
	 */

/**
	// End of segment: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\gui\InputColorFilter.java





	/**
	 * origin: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\gui\IOPane.java
	 */

public class IOPane extends JFrame {
    
    private static final Rectangle BOUNDS_CLOSE_BUTTON = new Rectangle(373, 10, 17, 17);
    private static final Rectangle BOUNDS_EXPORT_BUTTON = new Rectangle(55, 83, 81, 34);
    private static final Rectangle BOUNDS_PANE_GRAPHIC = new Rectangle(160, 50, 80, 100);
    private static final Rectangle BOUNDS_IMPORT_BUTTON = new Rectangle(264, 83, 81, 34);
    
    private static final Dimension DIMENSIONS_IO_PANE = new Dimension(400, 200);

    private static final String INVALID_FILENAME_REGEX = 
	    
    "# Match a valid Windows filename (unspecified file system).          \n" +
    "^                                # Anchor to start of string.        \n" +
    "(?!                              # Assert filename is not: CON, PRN, \n" +
    "  (?:                            # AUX, NUL, COM1, COM2, COM3, COM4, \n" +
    "    CON|PRN|AUX|NUL|             # COM5, COM6, COM7, COM8, COM9,     \n" +
    "    COM[1-9]|LPT[1-9]            # LPT1, LPT2, LPT3, LPT4, LPT5,     \n" +
    "  )                              # LPT6, LPT7, LPT8, and LPT9...     \n" +
    "  (?:\\.[^.]*)?                  # followed by optional extension    \n" +
    "  $                              # and end of string                 \n" +
    ")                                # End negative lookahead assertion. \n" +
    "[^<>:\"/\\\\|?*\\x00-\\x1F]*     # Zero or more valid filename chars.\n" +
    "[^<>:\"/\\\\|?*\\x00-\\x1F\\ .]  # Last char is not a space or dot.  \n" +
    "$                                # Anchor to end of string.            ";
    
    
    private static final String MESSAGE_EXPORT_FAILED = "Export Failed: Invalid filename";
    private static final String MESSAGE_EXPORT_SUCCESSFUL = "Exported \"%1$s\" sucessfully";
    private static final String MESSAGE_SUCCESSFUL_IMPORT = " was successfully imported into TASCA";
    
    private static final Border SETTINGS_EMPTY_BORDER = BorderFactory.createEmptyBorder(0,0,0,0);

    private static final String CHAR_QUOTATION_MARKS = "\"";
    
    private static final String FILETYPE_NAME_ICS = "iCal ICS File";
    private static final String FILETYPE_ICS = "ics";
    private static final String UI_BACKGROUND_COLOR_HEX = "#272822";
    
    private static final ImageIcon ICON_CLOSE = new ImageIcon(MainInterface.class.getResource("/GUI Graphics/Close button.png"));
    private static final ImageIcon ICON_EXPORT = new ImageIcon(MainInterface.class.getResource("/GUI Graphics/Export Pane Button.png"));
    private static final ImageIcon ICON_PANE_GRAPHIC = new ImageIcon(MainInterface.class.getResource("/GUI Graphics/Export Pane Graphics.png"));
    private static final ImageIcon ICON_IMPORT = new ImageIcon(MainInterface.class.getResource("/GUI Graphics/Import Pane Button.png"));
    
    private static final long serialVersionUID = 1L;

    private static final String TITLELESS_JFRAME = "TitleLessJFrame";
    private int dragPosX = 0, dragPosY = 0;
    JLabel systemStatusMessage;
    
    private Controller controller;
    
    public IOPane(JFrame mainFrame, JLabel systemStatusMessage, Controller controller) {
	super(TITLELESS_JFRAME);
	
	linkMainInterfaceComponents(systemStatusMessage, controller);
	
	loadGuiComponents(mainFrame);
	activateWindowDrag();
	setVisible(true);
    }

    private void linkMainInterfaceComponents(JLabel systemStatusMessage,
	    Controller controller) {
	this.systemStatusMessage = systemStatusMessage;
	this.controller = controller;
    }

    private void loadGuiComponents(final JFrame mainInterfaceFrame) {
	MainInterface.getExportBtn().setEnabled(false);
	
	loadFrameSettings(mainInterfaceFrame); 
	
	addCloseButton();
	addExportPaneGraphic();
	
	addImportButton(mainInterfaceFrame);
	addExportButton(mainInterfaceFrame);
    }

    private void addImportButton(final JFrame mainInterfaceFrame) {
	JButton btnImport = new JButton(ICON_IMPORT);
	btnImport.setBounds(BOUNDS_IMPORT_BUTTON); 
	btnImport.setContentAreaFilled(false);
	btnImport.setBorder(BorderFactory.createEmptyBorder());
	btnImport.addActionListener(new ActionListener() {
	    public void actionPerformed(ActionEvent e) {
		setAlwaysOnTop( false );
		activateImportFileFinder(mainInterfaceFrame);
	    }
	});  
	
	getContentPane().add(btnImport);
    }

    private void addExportPaneGraphic() {
	JLabel icon = new JLabel(ICON_PANE_GRAPHIC);
	icon.setBounds(BOUNDS_PANE_GRAPHIC); 
	
	getContentPane().add(icon);
    }

    private void loadFrameSettings(final JFrame mainInterfaceFrame) {
	setSize(DIMENSIONS_IO_PANE);
	setBackground(Color.decode(UI_BACKGROUND_COLOR_HEX));
	
	getContentPane().setBackground(Color.decode(UI_BACKGROUND_COLOR_HEX));
	getContentPane().setLayout(null);

	setUndecorated(true); 
	setAlwaysOnTop( true );
	setLocationByPlatform( true );
	
	setResizable(false); 
	setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	setLocationRelativeTo(mainInterfaceFrame);
    }

    private void addExportButton(final JFrame mainFrame) {
	JButton btnExport = new JButton(ICON_EXPORT);
	
	btnExport.setBounds(BOUNDS_EXPORT_BUTTON); 
	btnExport.setContentAreaFilled(false);
	btnExport.setBorder(BorderFactory.createEmptyBorder());
	btnExport.addActionListener(new ActionListener() {
	    public void actionPerformed(ActionEvent e) {
		setAlwaysOnTop( false );
		activateExportFileFinder(mainFrame);
	    }
	});  
	
	getContentPane().add(btnExport);
    }

    private void addCloseButton() {
	JButton btnClose = new JButton(ICON_CLOSE);

	btnClose.setBackground(Color.BLACK);
	btnClose.addActionListener(new ActionListener() {
	    public void actionPerformed(ActionEvent e) {
		executeQuit();
	    }
	});
	
	btnClose.setBorderPainted(false);
	btnClose.setContentAreaFilled(false);
	btnClose.setBorder(SETTINGS_EMPTY_BORDER);
	
	btnClose.setBounds(BOUNDS_CLOSE_BUTTON); 
	
	getContentPane().add(btnClose);
    }
    
    private void activateImportFileFinder(JFrame mainFrame) {
	JFileChooser chooser = new JFileChooser();
	FileNameExtensionFilter filter = new FileNameExtensionFilter(FILETYPE_NAME_ICS, FILETYPE_ICS);
	
	int userSelection = createOpenDialog(mainFrame, chooser, filter);
	
	if(userSelection == JFileChooser.APPROVE_OPTION) {
	   new Importer(chooser.getSelectedFile().getAbsolutePath(), controller);
	   systemStatusMessage.setText(CHAR_QUOTATION_MARKS + chooser.getSelectedFile().getName() + CHAR_QUOTATION_MARKS + MESSAGE_SUCCESSFUL_IMPORT);
	}
	
	MainInterface.updateTaskDisplay();
	executeQuit();
    }

    private int createOpenDialog(JFrame mainFrame, JFileChooser chooser,
	    FileNameExtensionFilter filter) {
	chooser.setFileFilter(filter);
	int returnVal = chooser.showOpenDialog(mainFrame);
	return returnVal;
    }
    
    private void activateWindowDrag() {
	addMouseListener(new MouseAdapter()
	{
	    public void mousePressed(MouseEvent e)
	    {
		dragPosX=e.getX();
		dragPosY=e.getY();
	    }
	});

	addMouseMotionListener(new MouseAdapter()
	{
	    public void mouseDragged(MouseEvent evt)
	    {			
		setLocation (evt.getXOnScreen()-dragPosX,evt.getYOnScreen()-dragPosY);
	    }
	});
    }

    private void executeQuit() {
	MainInterface.getExportBtn().setEnabled(true);
	dispose();
    }

    private void activateExportFileFinder(final JFrame frame) {
	JFileChooser chooser = new JFileChooser();
	FileNameExtensionFilter filter = new FileNameExtensionFilter(FILETYPE_NAME_ICS, FILETYPE_ICS);

	int userSelection = createSaveDialog(frame, chooser, filter);

	if(userSelection == JFileChooser.APPROVE_OPTION) {
	    String fileName = chooser.getSelectedFile().getName();

	    if (!isFilenameValid(fileName) ) {
		systemStatusMessage.setText(MESSAGE_EXPORT_FAILED);
		executeQuit();
	    }

	    saveToDestination(chooser, fileName);
	}

	executeQuit();
    }

    private void saveToDestination(JFileChooser chooser, String fileName) {
	String filePath = chooser.getSelectedFile().getAbsolutePath().replaceAll("/" + fileName, "");
	fileName = cleanFileName(fileName);
	
	new Exporter(filePath, fileName, controller);
	systemStatusMessage.setText(String.format(MESSAGE_EXPORT_SUCCESSFUL, fileName));
    }

    private int createSaveDialog(final JFrame frame, JFileChooser chooser,
	    FileNameExtensionFilter filter) {
	chooser.setFileFilter(filter);
	
	int returnVal = chooser.showSaveDialog(frame);
	return returnVal;
    }

    private String cleanFileName(String fileName) {
	fileName = fileName.replace(".", ""); 
	fileName = fileName.replace(".ics", ""); // .ics will be generated by iCal4j 
	fileName = fileName.replace(",", "");
	return fileName;
    }

    private static boolean isFilenameValid(String text)
    {
        Pattern pattern = Pattern.compile(INVALID_FILENAME_REGEX, 
            Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE | Pattern.COMMENTS);
        
        Matcher matcher = pattern.matcher(text);
        boolean isMatch = matcher.matches();
        return isMatch;
    }
}



	// End of segment: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\gui\IOPane.java





	/**
	 * origin: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\gui\KeywordItem.java
	 */

public class KeywordItem extends JLayeredPane {
    
    private static final Dimension BOUNDS_ITEM = new Dimension(396, 41);
    private static final Rectangle BOUNDS_SYNONYMS_TEXT_FIELD = new Rectangle(135, 8, 227, 24);
    private static final Rectangle BOUNDS_KEYWORD_LABEL = new Rectangle(0, 0, 123, 41);
    private static final Dimension DIMENSIONS_ITEM_BACKGROUND = BOUNDS_ITEM;
    
    private static final int MAX_COLUMNS = 10;
    private static final Color COLOR_UI_BACKGROUND = Color.decode("#443e3e");
    private static final String TEXT_DEFAULT_KEYWORD_LABEL = "Keyword";
    private static final Border SETTINGS_EMPTY_BORDER = BorderFactory.createEmptyBorder(0, 0, 0, 0);
    private static final long serialVersionUID = 1L;
    private static BufferedGraphics graphics = new BufferedGraphics();
    private JTextField synonymsField;
    
    public KeywordItem(String keyword, String synonyms) {
	super();
	
	loadItemSettings();
	
	addSynonymsTextField(synonyms);
	addKeywordLabel(keyword);
	
	addItemBackground();
    }

    private void addItemBackground() {
	JLabel background = new JLabel();
	background.setSize(DIMENSIONS_ITEM_BACKGROUND);
	background.setIcon(graphics.getKeywordItem());
	this.add(background);
    }

    private void addKeywordLabel(String keyword) {
	JLabel keywordLabel = new JLabel(TEXT_DEFAULT_KEYWORD_LABEL);
	keywordLabel.setHorizontalAlignment(SwingConstants.CENTER);
	keywordLabel.setForeground(Color.WHITE);
	keywordLabel.setFont(MainInterface.latoBold13);
	keywordLabel.setBounds(BOUNDS_KEYWORD_LABEL);
	keywordLabel.setText(keyword);
	add(keywordLabel);
    }

    private void addSynonymsTextField(String synonyms) {
	synonymsField = new JTextField();
	synonymsField.setBounds(BOUNDS_SYNONYMS_TEXT_FIELD); 
	synonymsField.setFont(MainInterface.latoReg13);
	synonymsField.setForeground(Color.WHITE);
	synonymsField.setBackground(COLOR_UI_BACKGROUND);
	synonymsField.setBorder(SETTINGS_EMPTY_BORDER);
	synonymsField.setText(synonyms);
	synonymsField.setCaretColor(Color.WHITE);
	synonymsField.setColumns(MAX_COLUMNS);
	add(synonymsField);
    }

    private void loadItemSettings() {
	this.setSize(BOUNDS_ITEM); 
	this.setBorder(SETTINGS_EMPTY_BORDER);
    }
    
    public String getInputText() {
	return synonymsField.getText();
    }
}

	// End of segment: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\gui\KeywordItem.java





	/**
	 * origin: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\gui\MainInterface.java
	 */

public class MainInterface {
   
    private static final int INVALID_INPUT_HISTORY_REF = -1;
    private static final int VERTICAL_GAP_BETWEEN_ITEMS = 13;
    private static final Color COLOR_UI_BACKGROUND = Color.decode("#272822");
    private static final int DISPLAY_PANE_MAX_HEIGHT = 262;

    private static final String FONT_NAME_LUCIDA_GRANDE = "Lucida Grande";
    private static final String FONT_NAME_LATO = "Lato";
    private static final String FONT_NAME_MESLO_BOLD = "Meslo LG S";
    private static final String FONT_NAME_MESLO_PLAIN = "Meslo LG M";

    private static final String FILEPATH_FONT_MESLO_BOLD = "/GUI Graphics/Fonts/MesloLGS-Bold.ttf";
    private static final String FILEPATH_FONT_MESLO_REG = "/GUI Graphics/Fonts/MesloLGM-Regular.ttf";
    private static final String FILEPATH_FONT_LUCIDA_GRANDE = "/GUI Graphics/Fonts/Lucida Grande.ttf";
    private static final String FILEPATH_FONT_LATO_REG = "/GUI Graphics/Fonts/Lato-Reg.ttf";
    
    private static final String INFO_CREATING_SETTINGS_PANE = "Creating settings pane";
    private static final String INFO_CREATING_IO_PANE = "Creating IOPane";
    private static final String MESSAGE_LOADING_FONTS_FAILED = "Could not load important fonts";

    private static Controller controller = new Controller();
    private static JFrame mainFrame;
    private static Logger logger = Controller.getLogger();
    
    // Window + components:
    public static Font mesloReg16, mesloBold16,menloReg, latoReg, latoReg15, latoReg14, latoReg12, latoBold13, latoBold20, latoBold16,latoReg13, lucidaReg22;
    private static int windowPosX=0,windowPosY=0;
    private static final String TITLELESS_JFRAME = "TitleLessJFrame";
    private static final Rectangle BOUNDS_MAIN_FRAME = new Rectangle(0, 0, 888, 500);
    
    private static final ImageIcon IMAGE_UI_BACKGROUND = new ImageIcon(MainInterface.class.getResource("/GUI Graphics/UI Background.png"));
    private static final ImageIcon ICON_EXPORT_BUTTON = new ImageIcon(MainInterface.class.getResource("/GUI Graphics/Export Icon.png"));
    private static final ImageIcon ICON_SETTINGS_BUTTON = new ImageIcon(MainInterface.class.getResource("/GUI Graphics/Settings Icon.png"));
    private static final ImageIcon ICON_INPUT_BACKGROUND = new ImageIcon(MainInterface.class.getResource("/GUI Graphics/Empty Input Bar.gif"));
    private static final ImageIcon ICON_FEEDBACK_BACKGROUND = new ImageIcon(MainInterface.class.getResource("/GUI Graphics/Error Feedback Background.png"));
    private static final ImageIcon ICON_CLOSE_BUTTON = new ImageIcon(MainInterface.class.getResource("/GUI Graphics/Close button.png"));
    private static final ImageIcon ICON_MINIMIZE_BUTTON = new ImageIcon(MainInterface.class.getResource("/GUI Graphics/Minimize Button.png"));
    
    private static final String FILEPATH_ICON_DOWN_INDICATOR = "/GUI Graphics/Size Arrow Down.png";
    private static final String FILEPATH_ICON_UP_INDICATOR = "/GUI Graphics/Size Arrow Up.png";
    
    private static final String MESSAGE_WELCOME = "memora vivere";
    private static final String MESSAGE_EMPTY_LIST = "Just do it. Later.";
    private static final Border SETTINGS_EMPTY_BORDER = BorderFactory.createEmptyBorder(0,0,0,0);
    private static final int VIEWPORT_HEIGHT_DISPLAY_PANE = 262;
    
    // Input bar & Input history:
    private static UserInputTextPane textPane;
    private static List<InputHistory.StateMemory> savedUserInput = new ArrayList<InputHistory.StateMemory>();
    private static InputHistory inputHistory = new InputHistory();
    private static int currentHistoryState = INVALID_INPUT_HISTORY_REF;
    private static int inputHistorySize = INVALID_INPUT_HISTORY_REF;
    private static final int MAX_INPUT_HISTORY = 30;
    
    private static final String SINGLE_SPACE = " ";
    private static final String DELIMITER = "-";

    // Folder tab manager:
    private static final int NUM_FOLDERS = 5;  
    private static FolderName currFolder, prevFolder, defaultFolder;
    private static String folder1Name, folder2Name, folder3Name, folder4Name, folder5Name;
    private static FolderName folderCycle[] = {FolderName.FOLDER1, FolderName.FOLDER2, FolderName.FOLDER3, FolderName.FOLDER4, FolderName.FOLDER5};
    private static FolderTab folder1, folder2, folder3, folder4, folder5;
    private static int cycleRef = 1;
    
    private static final Point LOCATION_FOLDER5 = new Point(636, 4);
    private static final Point LOCATION_FOLDER4 = new Point(477, 4);
    private static final Point LOCATION_FOLDER3 = new Point(318, 4);
    private static final Point LOCATION_FOLDER2 = new Point(159, 4);
    private static final Point LOCATION_FOLDER1 = new Point(-2, 4);

    // Display pane:
    private static JScrollPane taskPane;
    private static Interpreter interpreter;

    private static JButton btnSettings, btnExport;
    private static JLabel upIndicator, downIndicator, inputBackground, feedbackText, feedbackBackground, msgEmptyList, systemStatusMessage;

    private static Config cfg;
    
    private static SimpleAttributeSet parameterSetting = new SimpleAttributeSet();
    private static SimpleAttributeSet normalSetting = new SimpleAttributeSet();
    
    private static final int MAX_SCROLL_SPEED_IN_PIXELS = 1;
    private static final int SCROLL_THUMB_WIDTH = 16;
    private static final int DELAY_KEY_PRESS = 170;
    
    // Component Dimensions/Locations:    
    private static final Rectangle BOUNDS_CLOSE_BUTTON = new Rectangle(862, 7, 17, 17);
    private static final Rectangle BOUNDS_LAYERED_PANE = new Rectangle(0, 0, 888, 342);
    private static final Rectangle BOUNDS_TASK_PANE = new Rectangle(0, 80, 888, 262);
    private static final Rectangle BOUNDS_DOWN_INDICATOR = new Rectangle(861, 440, 18, 18);
    private static final Rectangle BOUNDS_UP_INDICATOR = new Rectangle(861, 412, 18, 18);
    private static final Rectangle BOUNDS_SCROLL_PANE = new Rectangle(50, 423, 745, 23);
    private static final Rectangle BOUNDS_EMPTY_LIST_MESSAGE = new Rectangle(214, 200, 460, 28);
    private static final Rectangle BOUNDS_SYSTEM_MESSAGE = new Rectangle(0, 484, 888, 16);
    private static final Rectangle BOUNDS_MINIMIZE_BUTTON = new Rectangle(836, 7, 18, 18);
    private static final Rectangle BOUNDS_INPUT_BAR_BACKGROUND = new Rectangle(37, 412, 814, 46);
    private static final Rectangle BOUNDS_FEEDBACK_TEXT_BACKGROUND = new Rectangle(77, 361, 750, 52);
    private static final Rectangle BOUNDS_FEEDBACK_TEXT = new Rectangle(99, 373, 694, 18);
    private static final Rectangle BOUNDS_SETTINGS_BUTTON = new Rectangle(505, 365, 27, 27);
    private static final Rectangle BOUNDS_EXPORT_BUTTON = new Rectangle(351, 365, 26, 26);
    
    private static final Dimension DIMENSIONS_TASK_ITEM = new Dimension(888, 40);
    private static final Dimension DIMENSIONS_MAIN_FRAME = new Dimension(888, 500);
    private static final Rectangle DISPLAY_PANE_BOUNDS = BOUNDS_TASK_PANE;

    // Input color filter:
    private static InputColorFilter colorFilter;
    static {
	StyleConstants.setBold((MutableAttributeSet) parameterSetting, false);
	StyleConstants.setForeground((MutableAttributeSet) parameterSetting, Color.WHITE);

	StyleConstants.setBold((MutableAttributeSet) normalSetting, false);
	StyleConstants.setForeground((MutableAttributeSet) normalSetting, Color.WHITE);
    }

    public MainInterface() {

	readFonts();
	customizeAndLoadFonts();

	loadFrameSettings();
	initializeGuiComponents(mainFrame);

	createShutdownHook();
	updateTaskDisplay();

	showMainFrame();
    }

    private void customizeAndLoadFonts() {

	mesloReg16 = new Font(FONT_NAME_MESLO_PLAIN, Font.PLAIN, 16);
	mesloBold16 = new Font(FONT_NAME_MESLO_BOLD, Font.BOLD, 16);

	latoBold20 = new Font(FONT_NAME_LATO, Font.BOLD, 20);
	latoBold16 = new Font(FONT_NAME_LATO, Font.BOLD, 16);

	latoReg15 = new Font(FONT_NAME_LATO, Font.PLAIN, 15);
	latoReg14 = new Font(FONT_NAME_LATO, Font.PLAIN, 14);
	latoReg13 = new Font(FONT_NAME_LATO, Font.PLAIN, 13);
	latoReg12 = new Font(FONT_NAME_LATO, Font.PLAIN, 12);

	lucidaReg22 = new Font(FONT_NAME_LUCIDA_GRANDE, Font.PLAIN, 22);

    }

    private void readFonts() {
	try {
	    GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
	    ge.registerFont(Font.createFont(Font.TRUETYPE_FONT, MainInterface.class.getResourceAsStream(FILEPATH_FONT_LATO_REG)));
	    ge.registerFont(Font.createFont(Font.TRUETYPE_FONT, MainInterface.class.getResourceAsStream(FILEPATH_FONT_LUCIDA_GRANDE)));
	    ge.registerFont(Font.createFont(Font.TRUETYPE_FONT, MainInterface.class.getResourceAsStream(FILEPATH_FONT_MESLO_REG)));
	    ge.registerFont(Font.createFont(Font.TRUETYPE_FONT, MainInterface.class.getResourceAsStream(FILEPATH_FONT_MESLO_BOLD)));

	} catch (IOException | FontFormatException e) {
	    logger.log(Level.SEVERE, MESSAGE_LOADING_FONTS_FAILED + e.getStackTrace());
	    Assert.fail(MESSAGE_LOADING_FONTS_FAILED);
	}
    }

    public static void main(String[] args)  {

	SwingUtilities.invokeLater(new Runnable() {
	    public void run() {
		new MainInterface();
	    }
	});

    }

    public static boolean getIsActiveFeedbackEnabled() {
	return cfg.getIsActiveFeedbackEnabled();
    }

    
    public static boolean getIsDefaultCollated() {
	return cfg.getIsDefaultCollated();
    }

    public static void loadAllFolderLabels(){
	cfg = new Config();

	folder1Name = cfg.getFolderName(FolderName.FOLDER1);
	folder2Name = cfg.getFolderName(FolderName.FOLDER2);
	folder3Name = cfg.getFolderName(FolderName.FOLDER3);
	folder4Name = cfg.getFolderName(FolderName.FOLDER4);
	folder5Name = cfg.getFolderName(FolderName.FOLDER5);

	setDefaultFolder(cfg.getDefaultFolder());
    }

    public static void updateAllFolderLabels() {

	folder1.setLabelText(folder1Name);
	folder2.setLabelText(folder2Name);
	folder3.setLabelText(folder3Name);
	folder4.setLabelText(folder4Name);
	folder5.setLabelText(folder5Name);

    }


    private static LinkedList<TaskWithReminder> folderSortTimedTasks() {

	LinkedList<TaskWithReminder> original = getController().getCurrentSystemState().getTimedList();
	LinkedList<TaskWithReminder> folderSortedList = new LinkedList<TaskWithReminder>();

	for (int i=0; i<original.size(); i++) {
	    if (isCurrentFolder(getReminderFolder(original, i))) {
		folderSortedList.add(original.get(i));
	    }
	}

	return folderSortedList;
    }

    private static FolderName getReminderFolder(LinkedList<TaskWithReminder> original, int index) {
	return cfg.getFolderId(original.get(index).getTask().getFolder());
    }

    private static boolean isCurrentFolder(FolderName folder) {

	if (getIsDefaultCollated()) {
	    return folder == getCurrFolder() ||  getCurrFolder() == getDefaultFolder();
	} else {
	    return folder == getCurrFolder() || (folder == FolderName.DEFAULT && getCurrFolder() == getDefaultFolder());
	}
	
    }

    private static LinkedList<FloatingTask> folderSortFloatingTasks() {

	LinkedList<FloatingTask> original = getController().getCurrentSystemState().getFloatingList();
	LinkedList<FloatingTask> folderSortedList = new LinkedList<FloatingTask>();
	
	for (int i=0; i<original.size(); i++) {
	    if (isCurrentFolder(getTaskFolder(original, i))) {
		folderSortedList.add(original.get(i));
	    }
	}
	
	return folderSortedList;
    }

    private static FolderName getTaskFolder(LinkedList<FloatingTask> original, int index) {
	return cfg.getFolderId(original.get(index).getFolder());
    }

    public static void updateTaskDisplay() {
	int currentScrollPos = getVeriticalScrollPos();

	LinkedList<TaskWithReminder> folderSortedTimedTasks = folderSortTimedTasks(); 
	LinkedList<FloatingTask> folderSortedFloatingTasks = folderSortFloatingTasks();

	if (isListEmpty(folderSortedTimedTasks, folderSortedFloatingTasks)) {
	    taskPane.setVisible(false);
	    msgEmptyList.setVisible(true);
	    return;
	} else {
	    msgEmptyList.setVisible(false);
	}

	JPanel displayPanel = initDisplayPanel(folderSortedTimedTasks, folderSortedFloatingTasks); 
	rebuildItemList(currentScrollPos, folderSortedTimedTasks,folderSortedFloatingTasks, displayPanel);
	refreshColorFilter();
    }

    private static void refreshColorFilter() {
	if (!textPane.getText().isEmpty() && !textPane.getText().equals(MESSAGE_WELCOME)) {
		colorFilter.checkForInterpreterExceptions(textPane.getText());
	}
    }

    private static void rebuildItemList(int scrollPos,
	    LinkedList<TaskWithReminder> folderSortedTimedTasks,
	    LinkedList<FloatingTask> folderSortedFloatingTasks,
	    JPanel displayPanel) {

	int numOfTimedTasks = addTimedTasks(folderSortedTimedTasks, displayPanel);
	addFloatingTasks(folderSortedFloatingTasks, displayPanel, numOfTimedTasks);

	adjustDisplayViewport(displayPanel, scrollPos);
	updateStatusMessage();

    }

    private static void updateStatusMessage() {
	getSystemStatusMessage().setText(getController().getSystemMessageString());
    }

    private static JPanel initDisplayPanel(LinkedList<TaskWithReminder> folderSortedTimedTasks, LinkedList<FloatingTask> folderSortedFloatingTasks) {

	JPanel displayPanel = new JPanel(new GridLayout(folderSortedTimedTasks.size() + folderSortedFloatingTasks.size(), 0, 0, VERTICAL_GAP_BETWEEN_ITEMS));
	displayPanel.setBackground(COLOR_UI_BACKGROUND);
	Interpreter.clearGuiIdMap();

	return displayPanel;
    }

    private static void adjustDisplayViewport(JPanel displayPanel, int previousScrollPos) {
	double preferredHeight = displayPanel.getPreferredSize().getHeight(); 

	if (preferredHeight < DISPLAY_PANE_MAX_HEIGHT) {
	    taskPane.setSize(displayPanel.getPreferredSize());
	} else {
	    taskPane.setBounds(DISPLAY_PANE_BOUNDS);
	}

	taskPane.setViewportView(displayPanel);
	taskPane.setVisible(true);

	setVerticalScollPos(previousScrollPos);
    }

    private static void addFloatingTasks(
	    LinkedList<FloatingTask> folderSortedFloatingTasks,
	    JPanel displayPanel, int numOfTimedTasks) {

	for (int i = 0; i < folderSortedFloatingTasks.size(); i++) {
	    TaskItem taskBar = new TaskItem(textPane, getController(), computeFloatingTaskGuiId(numOfTimedTasks, i), interpreter);
	    taskBar.loadFloatingTaskDetails(folderSortedFloatingTasks.get(i), computeFloatingTaskGuiId(numOfTimedTasks, i));
	    
	    Interpreter.addGuiId(computeFloatingTaskGuiId(numOfTimedTasks, i), folderSortedFloatingTasks.get(i).getTaskID());
	    loadTaskItemProperties(displayPanel, taskBar);
	}
    }

    private static int computeFloatingTaskGuiId(int numOfTimedTasks, int index) {
	return index + 1 + numOfTimedTasks;
    }

    private static void loadTaskItemProperties(JPanel displayPanel,
	    TaskItem taskBar) {
	taskBar.setPreferredSize(DIMENSIONS_TASK_ITEM);
	taskBar.setVisible(true);
	displayPanel.add(taskBar);
    }

    private static int addTimedTasks(
	    LinkedList<TaskWithReminder> folderSortedTimedTasks, JPanel displayPanel) {
	
	int i;
	for (i=0; i < folderSortedTimedTasks.size(); i++) {
	    TaskItem taskBar = new TaskItem(textPane, getController(), computeTimedTaskGuiId(i), interpreter);
	    taskBar.loadTimedTaskDetails(folderSortedTimedTasks.get(i).getTask(), computeTimedTaskGuiId(i), folderSortedTimedTasks.get(i).getReminderTime());

	    Interpreter.addGuiId(computeTimedTaskGuiId(i), folderSortedTimedTasks.get(i).getTask().getTaskID());
	    loadTaskItemProperties(displayPanel, taskBar);
	}
	
	Interpreter.setFloatingTaskGuiRef(i+1);
	
	return i;
    }

    private static int computeTimedTaskGuiId(int index) {
	return index+1;
    }

    private static boolean isListEmpty(
	    LinkedList<TaskWithReminder> folderSortedTimedTasks,
	    LinkedList<FloatingTask> folderSortedFloatingTasks) {
	return folderSortedTimedTasks.size() + folderSortedFloatingTasks.size() == 0;
    }

    public static void clearTextPane() {

	if (savedUserInput.size() > MAX_INPUT_HISTORY) {
	    savedUserInput.clear();
	    setCurrentHistoryState(INVALID_INPUT_HISTORY_REF);
	}

	if (!textPane.getText().trim().isEmpty()) {
	    inputHistory.set(textPane.getText());
	    savedUserInput.add(inputHistory.saveToHistory());
	    setCurrentHistoryState(getCurrentHistoryState() + 1); // increment current state pointer 
	    setInputHistorySize(getInputHistorySize() + 1); 
	}

	textPane.setText("");
    }

    public static int getVeriticalScrollPos() {
	return taskPane.getVerticalScrollBar().getValue();
    }

    public static void setVerticalScollPos(int yPos) {
	taskPane.getVerticalScrollBar().setValue(yPos);
    }


    public static JButton getSettingsBtn() {
	return btnSettings;
    }

    public static JButton getExportBtn() {
	return btnExport;
    }

    public static void setUpIndicator(boolean state) {
	upIndicator.setVisible(state);
    }

    public static void setDownIndicator(boolean state) {
	downIndicator.setVisible(state);
    }


    private static void initializeGuiComponents(final JFrame currFrame) {

	loadAllFolderLabels();
	initDefaultFolderState();

	addCloseButton(currFrame);
	addMinimizeButton(currFrame);

	createTaskListPane(currFrame);

	initLabels();
	createInputBar(currFrame, inputBackground, feedbackText, feedbackBackground);   

	createEmptyListMessageLabel();
	createSystemMessageLabel();
	createFolderTabs(currFrame);
	createActiveFeedback(currFrame);

	addSettingsButton(currFrame);
	addExportButton(currFrame);

	setMainFrameBackground(currFrame);
	addWindowDragListener(currFrame);
	addKeyboardShortcutListener();
	
    }

    private static void addKeyboardShortcutListener() {
	KeyboardFocusManager.getCurrentKeyboardFocusManager()
	.addKeyEventDispatcher(new KeyEventDispatcher() {
	    private long lastPressTime = 0;

	    @Override
	    public boolean dispatchKeyEvent(KeyEvent keyEvent) {

		if(System.currentTimeMillis() - lastPressTime > DELAY_KEY_PRESS) {
		    executeShortcut(keyEvent);
		    lastPressTime = System.currentTimeMillis();
		}
		
		return false; //continue to monitor other key events
	    }

	});
    }

    private static void addWindowDragListener(final JFrame currFrame) {
	currFrame.addMouseListener(new MouseAdapter()
	{
	    public void mousePressed(MouseEvent event)
	    {
		windowPosX=event.getX();
		windowPosY=event.getY();
	    }
	});

	currFrame.addMouseMotionListener(new MouseAdapter()
	{
	    public void mouseDragged(MouseEvent event)
	    {
		//sets frame position when mouse dragged			
		currFrame.setLocation (event.getXOnScreen()-windowPosX,event.getYOnScreen()-windowPosY);

	    }
	});
    }

    private static void setMainFrameBackground(final JFrame frame) {
	JLabel mainFrameBackground = new JLabel(IMAGE_UI_BACKGROUND);
	mainFrameBackground.setBackground(Color.BLACK);
	mainFrameBackground.setBounds(BOUNDS_MAIN_FRAME);	
	frame.getContentPane().add(mainFrameBackground);
    }

    private static void addExportButton(final JFrame frame) {
	btnExport = new JButton(ICON_EXPORT_BUTTON);
	btnExport.setBounds(BOUNDS_EXPORT_BUTTON);
	btnExport.setContentAreaFilled(false);
	btnExport.setBorder(BorderFactory.createEmptyBorder());
	btnExport.addActionListener(new ActionListener() {
	    public void actionPerformed(ActionEvent e) {
		logger.log(Level.INFO, INFO_CREATING_IO_PANE);
		new IOPane(frame, getSystemStatusMessage(), getController());
	    }
	});   

	frame.getContentPane().add(btnExport);
    }

    private static void addSettingsButton(final JFrame frame) {
	btnSettings = new JButton(ICON_SETTINGS_BUTTON);
	btnSettings.setBounds(BOUNDS_SETTINGS_BUTTON);
	btnSettings.setContentAreaFilled(false);
	btnSettings.setBorder(BorderFactory.createEmptyBorder());
	btnSettings.addActionListener(new ActionListener() {
	    public void actionPerformed(ActionEvent e) {
		logger.log(Level.INFO, INFO_CREATING_SETTINGS_PANE);
		initiateSettingsPane(frame);
	    }
	});     
	frame.getContentPane().add(btnSettings);
    }

    private static void createActiveFeedback(final JFrame frame) {
	feedbackText.setHorizontalAlignment(SwingConstants.CENTER);
	feedbackText.setForeground(Color.WHITE);
	feedbackText.setFont(latoReg15);
	feedbackText.setBounds(BOUNDS_FEEDBACK_TEXT);
	frame.getContentPane().add(feedbackText);

	feedbackBackground.setIcon(ICON_FEEDBACK_BACKGROUND);
	feedbackBackground.setBounds(BOUNDS_FEEDBACK_TEXT_BACKGROUND);
	frame.getContentPane().add(feedbackBackground);

	feedbackText.setVisible(false);
	feedbackBackground.setVisible(false);

	inputBackground.setIcon(ICON_INPUT_BACKGROUND);
	inputBackground.setBounds(BOUNDS_INPUT_BAR_BACKGROUND);
	frame.getContentPane().add(inputBackground);
    }

    private static void createFolderTabs(final JFrame frame) {
	folder1 = new FolderTab(FolderName.FOLDER1, LOCATION_FOLDER1, folder1Name);
	frame.getContentPane().add(folder1);

	folder2 = new FolderTab(FolderName.FOLDER2, LOCATION_FOLDER2, folder2Name);
	frame.getContentPane().add(folder2);

	folder3 = new FolderTab(FolderName.FOLDER3, LOCATION_FOLDER3, folder3Name);
	frame.getContentPane().add(folder3);

	folder4 = new FolderTab(FolderName.FOLDER4, LOCATION_FOLDER4, folder4Name);
	frame.getContentPane().add(folder4);

	folder5 = new FolderTab(FolderName.FOLDER5, LOCATION_FOLDER5, folder5Name);
	frame.getContentPane().add(folder5);
    }

    private static void initLabels() {
	inputBackground = new JLabel("");
	feedbackText = new JLabel("");
	feedbackBackground = new JLabel("");
    }

    private static void processCtrlShortcuts(KeyEvent event) {
	if (isStartTimeShortcut(event)) {
	    
	    appendToTextPane(textPane, DELIMITER + interpreter.getDefaultParaSyn(ParameterType.START_TIME), ParameterType.START_TIME);
	    
	} else if (isModifyCommandShortcut(event)) {
	    
	    clearTextPane();
	    textPane.replaceSelection(interpreter.getDefaultCommandSyn(CommandType.MODIFY) + SINGLE_SPACE + DELIMITER + interpreter.getDefaultParaSyn(ParameterType.TASK_ID) + SINGLE_SPACE);
	    
	} else if (isIdShortcut(event)) {

	    appendToTextPane(textPane, DELIMITER + interpreter.getDefaultParaSyn(ParameterType.TASK_ID), ParameterType.TASK_ID);
	    
	} else if (isEndTimeShortcut(event)) {
	    
	    appendToTextPane(textPane, DELIMITER + interpreter.getDefaultParaSyn(ParameterType.END_TIME), ParameterType.END_TIME);
	    
	} else if (isPriorityShortcut(event)) {
	    
	    appendToTextPane(textPane, DELIMITER + interpreter.getDefaultParaSyn(ParameterType.PRIORITY), ParameterType.PRIORITY);
	    
	} else if (isReminderShortcut(event)) {
	    
	    appendToTextPane(textPane, DELIMITER + interpreter.getDefaultParaSyn(ParameterType.REMINDER_TIME), ParameterType.REMINDER_TIME);
	    
	} else if (isLocationShortcut(event)) {
	    
	    appendToTextPane(textPane, DELIMITER + interpreter.getDefaultParaSyn(ParameterType.LOCATION), ParameterType.LOCATION);
	    
	} else if (isFolderShortcut(event)) {
	    
	    appendToTextPane(textPane, DELIMITER + interpreter.getDefaultParaSyn(ParameterType.FOLDER), ParameterType.FOLDER);
	    
	} else if (isTextPaneFocusShortcut(event)) {
	    
	    textPane.requestFocus();
	    
	} else if (isFolderRightSwitchShortcut(event)) {
	 
	    executeFolderRightSwitch();

	} else if (isFolderLeftSwitchShortcut(event)) {
	    
	    executeFolderLeftSwitch();

	} else if (isPageUpShortcut(event)) {
	    
	    taskPane.getVerticalScrollBar().setValue((taskPane.getVerticalScrollBar().getValue()) - VIEWPORT_HEIGHT_DISPLAY_PANE);
	    
	} else if (isPageDownShortcut(event)) {
	    
	    taskPane.getVerticalScrollBar().setValue((taskPane.getVerticalScrollBar().getValue()) + VIEWPORT_HEIGHT_DISPLAY_PANE);
	}

	refreshColorFilter();
    }

    private static void executeFolderLeftSwitch() {
	setCycleRef((getCycleRef() + NUM_FOLDERS - 1) % NUM_FOLDERS);
	FolderName nextFolder = getFolderCycle()[getCycleRef()];

	FolderTab.gotoFolder(nextFolder);
    }

    private static void executeFolderRightSwitch() {
	setCycleRef((getCycleRef() + NUM_FOLDERS + 1) % NUM_FOLDERS);

	FolderName nextFolder = getFolderCycle()[getCycleRef()];

	FolderTab.gotoFolder(nextFolder);
    }

    private static boolean isPageDownShortcut(KeyEvent event) {
	return isInputHistoryForwardShortcut(event);
    }

    private static boolean isPageUpShortcut(KeyEvent event) {
	return isInputHistoryBackShortcut(event);
    }

    private static boolean isFolderLeftSwitchShortcut(KeyEvent event) {
	return event.getKeyCode() == KeyEvent.VK_TAB && event.isShiftDown();
    }

    private static boolean isFolderRightSwitchShortcut(KeyEvent event) {
	return event.getKeyCode() == KeyEvent.VK_TAB && !event.isShiftDown();
    }

    private static boolean isTextPaneFocusShortcut(KeyEvent event) {
	return event.getKeyCode() == KeyEvent.VK_T;
    }

    private static boolean isFolderShortcut(KeyEvent event) {
	return event.getKeyCode() == KeyEvent.VK_F;
    }

    private static boolean isLocationShortcut(KeyEvent event) {
	return event.getKeyCode() == KeyEvent.VK_L;
    }

    private static boolean isReminderShortcut(KeyEvent event) {
	return event.getKeyCode() == KeyEvent.VK_R || event.getKeyCode() == KeyEvent.VK_A;
    }

    private static boolean isPriorityShortcut(KeyEvent event) {
	return event.getKeyCode() == KeyEvent.VK_P;
    }

    private static boolean isEndTimeShortcut(KeyEvent event) {
	return event.getKeyCode() == KeyEvent.VK_E || event.getKeyCode() == KeyEvent.VK_D;
    }

    private static boolean isIdShortcut(KeyEvent event) {
	return event.getKeyCode() == KeyEvent.VK_N || event.getKeyCode() == KeyEvent.VK_I;
    }

    private static boolean isModifyCommandShortcut(KeyEvent event) {
	return event.getKeyCode() == KeyEvent.VK_M && event.isShiftDown();
    }

    private static boolean isStartTimeShortcut(KeyEvent event) {
	return event.getKeyCode() == KeyEvent.VK_S || event.getKeyCode() == KeyEvent.VK_O;
    }

    private static void appendToTextPane(UserInputTextPane textPane, String newString, ParameterType parameterType) {
	
	if (textPane.getText().isEmpty()) {
	    return;
	}

	if (parameterAlreadyExists(textPane, newString)) {
	    textPane.setCaretPosition(textPane.getText().indexOf(newString)+newString.length() + 1);
	    return;
	}

	if (hasTrailingSpace(textPane)) {
	    newString = SINGLE_SPACE + newString;
	}

	StyleConstants.setForeground((MutableAttributeSet) parameterSetting, InputColorFilter.getParameterColor(parameterType));

	try {
	    textPane.appendParameter(newString, parameterSetting);
	    textPane.appendParameter(SINGLE_SPACE, normalSetting);
	    textPane.setCaretPosition(textPane.getText().length());
	} catch (BadLocationException e) {
	    logger.log(Level.WARNING, "" + e.getStackTrace());
	}

    }

    private static boolean hasTrailingSpace(UserInputTextPane textPane) {
	return textPane.getText().charAt(textPane.getText().length() - 1) != ' ';
    }

    private static boolean parameterAlreadyExists(UserInputTextPane textPane,
	    String newString) {
	return textPane.getText().indexOf(newString) >= 0;
    }

    private static void addMinimizeButton(final JFrame frame) {
	JButton btnMinimize = new JButton("");
	btnMinimize.setBackground(Color.BLACK);
	btnMinimize.addMouseListener(new MouseAdapter() {
	    @Override
	    public void mouseClicked(MouseEvent e) {
		frame.setState(JFrame.ICONIFIED);
	    }
	});
	btnMinimize.setIcon(ICON_MINIMIZE_BUTTON);
	btnMinimize.setBounds(BOUNDS_MINIMIZE_BUTTON);

	btnMinimize.setBorderPainted(false);
	btnMinimize.setContentAreaFilled(false);
	btnMinimize.setBorder(SETTINGS_EMPTY_BORDER);

	frame.getContentPane().add(btnMinimize);
    }

    private static void createSystemMessageLabel() {
	setSystemStatusMessage(new JLabel(""));
	getSystemStatusMessage().setHorizontalAlignment(SwingConstants.CENTER);
	getSystemStatusMessage().setBounds(BOUNDS_SYSTEM_MESSAGE);
	getSystemStatusMessage().setFont(latoReg12);
	getSystemStatusMessage().setForeground(Color.WHITE);

	mainFrame.getContentPane().add(getSystemStatusMessage());
    }

    private static void createEmptyListMessageLabel() {
	msgEmptyList = new JLabel(MESSAGE_EMPTY_LIST);
	msgEmptyList.setForeground(Color.WHITE);
	msgEmptyList.setHorizontalAlignment(SwingConstants.CENTER);
	msgEmptyList.setFont(lucidaReg22);
	msgEmptyList.setBounds(BOUNDS_EMPTY_LIST_MESSAGE);
	msgEmptyList.setVisible(false);
	mainFrame.getContentPane().add(msgEmptyList);
    }

    private static void createInputBar(final JFrame frame, JLabel inputBackground,
	    JLabel feedbackText, JLabel feedbackBackground) {
	
	createInputTextPane(); 
	initIndicators(frame);
	
	addInputColorFilter(frame, inputBackground, feedbackText, feedbackBackground);
	
	createInputScrollPane(frame);
    }

    private static void addInputColorFilter(final JFrame frame,
	    JLabel inputBackground, JLabel feedbackText,
	    JLabel feedbackBackground) {
	colorFilter = (InputColorFilter.getInstance(frame, textPane, interpreter, inputBackground, feedbackText, feedbackBackground));
	((AbstractDocument) textPane.getDocument()).setDocumentFilter(colorFilter);
    }

    private static void createInputScrollPane(final JFrame frame) {
	JScrollPane scrollPane = new JScrollPane(textPane);
	scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);
	scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
	scrollPane.setBounds(BOUNDS_SCROLL_PANE);
	scrollPane.setOpaque(false);
	scrollPane.setBorder(SETTINGS_EMPTY_BORDER);


	scrollPane.getViewport().setOpaque(false);
	scrollPane.setViewportView(textPane);
	frame.getContentPane().add(scrollPane);
    }

    private static void createInputTextPane() {
	textPane = new UserInputTextPane(new DefaultStyledDocument());
	textPane.setOpaque(false);
	textPane.setText(MESSAGE_WELCOME);
	textPane.setFont(mesloReg16);
	textPane.setForeground(Color.WHITE);
	textPane.setFocusTraversalKeysEnabled(false);
	textPane.setCaretColor(Color.WHITE);

	interpreter = new Interpreter();
	Interpreter.setIsGuiIdEnabled(true);
    }

    private static void initIndicators(final JFrame frame) {
	try {
	    upIndicator = new JLabel(new ImageIcon(ImageIO.read((MainInterface.class.getResource(FILEPATH_ICON_UP_INDICATOR)))));
	} catch (IOException exception) {
	    logger.log(Level.SEVERE, BufferedGraphics.MESSAGE_GRAPHICS_LOAD_FAILED + exception.getStackTrace());
	    Assert.fail(BufferedGraphics.MESSAGE_GRAPHICS_LOAD_FAILED);
	}

	upIndicator.setBounds(BOUNDS_UP_INDICATOR);
	upIndicator.setVisible(false);
	frame.getContentPane().add(upIndicator);

	try {
	    downIndicator = new JLabel(new ImageIcon(ImageIO.read((MainInterface.class.getResource(FILEPATH_ICON_DOWN_INDICATOR)))));
	} catch (IOException exception) {
	    logger.log(Level.SEVERE, BufferedGraphics.MESSAGE_GRAPHICS_LOAD_FAILED + exception.getStackTrace());
	    Assert.fail(BufferedGraphics.MESSAGE_GRAPHICS_LOAD_FAILED);
	}

	downIndicator.setBounds(BOUNDS_DOWN_INDICATOR);
	downIndicator.setVisible(false);
	frame.getContentPane().add(downIndicator);
    }

    private static void createShutdownHook() {
	Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {

	    public void run() {
		getController().executeCommands(interpreter.getDefaultCommandSyn(CommandType.QUIT));
	    }
	}));
    }

    private static void createTaskListPane(final JFrame frame) {
	JLayeredPane layeredPane = initLayeredPane();

	buildTaskPane(layeredPane);

	frame.getContentPane().add(layeredPane);
    }

    private static void buildTaskPane(JLayeredPane layeredPane) {
	taskPane = new JScrollPane();
	taskPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
	taskPane.setBounds(BOUNDS_TASK_PANE);
	taskPane.setOpaque(false);
	taskPane.setBorder(SETTINGS_EMPTY_BORDER);
	taskPane.getViewport().setOpaque(false);
	taskPane.setOpaque(false);
	taskPane.setVisible(true);
	taskPane.setDoubleBuffered(true);

	addScrollBar();

	layeredPane.add(taskPane);
    }

    private static JLayeredPane initLayeredPane() {
	JLayeredPane layeredPane = new JLayeredPane();
	layeredPane.setBounds(BOUNDS_LAYERED_PANE);
	layeredPane.setOpaque(false);
	layeredPane.setBorder(SETTINGS_EMPTY_BORDER);
	return layeredPane;
    }

    private static void addScrollBar() {
	JScrollBar mainScrollBar = taskPane.getVerticalScrollBar();
	mainScrollBar.setPreferredSize(new Dimension(SCROLL_THUMB_WIDTH, Integer.MAX_VALUE));
	mainScrollBar.setUI(new ScrollBarUI());

	taskPane.getVerticalScrollBar().setUnitIncrement(MAX_SCROLL_SPEED_IN_PIXELS);
    }

    private static void addCloseButton(final JFrame frame) {
	JButton btnClose = new JButton(ICON_CLOSE_BUTTON);

	btnClose.setBackground(Color.BLACK);
	btnClose.addActionListener(new ActionListener() {
	    public void actionPerformed(ActionEvent e) {
		System.exit(0);
	    }
	});

	btnClose.setBorderPainted(false);
	btnClose.setContentAreaFilled(false);
	btnClose.setBorder(SETTINGS_EMPTY_BORDER);

	btnClose.setBounds(BOUNDS_CLOSE_BUTTON);
	frame.getContentPane().add(btnClose);
    }

    private static void initDefaultFolderState() {
	setCurrFolder(getDefaultFolder());
	setPrevFolder(getCurrFolder());

	setCycleRef(Integer.parseInt(getDefaultFolder().toString().charAt(6) + "" ) - 1); // char at index 6 in FolderName contains the folder id number
    }

    private static void loadFrameSettings() {
        mainFrame = new JFrame(TITLELESS_JFRAME);

        mainFrame.setBackground(COLOR_UI_BACKGROUND);
        mainFrame.getContentPane().setLayout(null);
        mainFrame.setUndecorated(true); 
        mainFrame.setSize(DIMENSIONS_MAIN_FRAME);
        mainFrame.setResizable(false); 
        mainFrame.setLocationRelativeTo(null); 
        mainFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	
    }

    private static void initiateSettingsPane(final JFrame frame) {
	new SettingsPane(frame, interpreter, cfg);
    }


    public static String getCurrentFolderName() {
	return cfg.getFolderName(getCurrFolder());
    }

    public static JLabel getSystemStatusMessage() {
	return systemStatusMessage;
    }

    public static void setSystemStatusMessage(JLabel systemStatusMessage) {
	MainInterface.systemStatusMessage = systemStatusMessage;
    }

    private static void showMainFrame() {
	mainFrame.setVisible(true);
	textPane.requestFocus();
    }

    public static int getCycleRef() {
	return cycleRef;
    }

    public static void setCycleRef(int cycleRef) {
	MainInterface.cycleRef = cycleRef;
    }

    public static FolderName[] getFolderCycle() {
	return folderCycle;
    }

    public static void setFolderCycle(FolderName folderCycle[]) {
	MainInterface.folderCycle = folderCycle;
    }

    public static FolderName getCurrFolder() {
	return currFolder;
    }

    public static void setCurrFolder(FolderName currFolder) {
	MainInterface.currFolder = currFolder;
    }

    public static FolderName getPrevFolder() {
	return prevFolder;
    }

    public static void setPrevFolder(FolderName prevFolder) {
	MainInterface.prevFolder = prevFolder;
    }

    public static FolderName getDefaultFolder() {
	return defaultFolder;
    }

    public static void setDefaultFolder(FolderName defaultFolder) {
	MainInterface.defaultFolder = defaultFolder;
    }

    public static int getCurrentHistoryState() {
	return currentHistoryState;
    }

    public static void setCurrentHistoryState(int inputNumRef) {
	MainInterface.currentHistoryState = inputNumRef;
    }

    public static int getInputHistorySize() {
	return inputHistorySize;
    }

    public static void setInputHistorySize(int inputHistorySize) {
	MainInterface.inputHistorySize = inputHistorySize;
    }

    public static Controller getController() {
	return controller;
    }

    public static void setController(Controller controller) {
	MainInterface.controller = controller;
    }

    private static void executeShortcut(KeyEvent event) {
	if (event.isControlDown()){
	    processCtrlShortcuts(event);
	}
	else if (event.isShiftDown()) {
	    processShiftOnlyShortcuts(event); 
	}
    }

    private static void processShiftOnlyShortcuts(KeyEvent event) {
	if (isInputHistoryBackShortcut(event)) {
	    executeInputHistoryBackwark();
	} else if (isInputHistoryForwardShortcut(event)) {
	    executeInputHistoryForward();
	}
    }

    private static void executeInputHistoryBackwark() {
	if (getCurrentHistoryState() >= 0) {
	    textPane.setText("");
	    textPane.replaceSelection(inputHistory.restoreFromHistory(savedUserInput.get(getCurrentHistoryState())));
	    setCurrentHistoryState(getCurrentHistoryState() - 1);
	}
    }

    private static void executeInputHistoryForward() {
	if (getCurrentHistoryState() + 2 < savedUserInput.size()) { // + 2 checks if there is one more forward state left
	    setCurrentHistoryState(getCurrentHistoryState() + 1);
	    textPane.setText("");
	    textPane.replaceSelection(inputHistory.restoreFromHistory(savedUserInput.get(getCurrentHistoryState()+1)));
	}
    }

    private static boolean isInputHistoryForwardShortcut(KeyEvent event) {
	return event.getKeyCode() == KeyEvent.VK_DOWN;
    }

    private static boolean isInputHistoryBackShortcut(KeyEvent event) {
	return event.getKeyCode() == KeyEvent.VK_UP;
    }

}




	// End of segment: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\gui\MainInterface.java





	/**
	 * origin: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\gui\ProgressBar.java
	 */

public class ProgressBar extends JLabel
{

    private static final Color COLOR_PROGRESS_INDICATOR = Color.decode("#302a28");
    private static final int INITIAL_HEIGHT_BAR = 40;
    private static final int INITIAL_WIDTH_BAR = 888;
    
    private static final long serialVersionUID = 1L;

    private double xCoordinate, yCoordinate;
    private Double rectangle;  

    public ProgressBar(double xCoordinate,double yCoordinate)
    {
	linkMainInterfaceComponents(xCoordinate, yCoordinate);
	drawRectangle();
    }

    private void drawRectangle() {
	rectangle = new Rectangle2D.Double(this.xCoordinate , this.yCoordinate, INITIAL_WIDTH_BAR, INITIAL_HEIGHT_BAR);
    }

    private void linkMainInterfaceComponents(double xCoordinate,
	    double yCoordinate) {
	this.xCoordinate = xCoordinate;
	this.yCoordinate = yCoordinate;
    }

    @Override
    public void paintComponent(Graphics originalGraphics) 
    {
	super.paintComponent(originalGraphics);  
	Graphics2D newGraphics = (Graphics2D) originalGraphics;
	newGraphics.setColor(COLOR_PROGRESS_INDICATOR);
	newGraphics.fill(rectangle);
    }
}
	// End of segment: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\gui\ProgressBar.java





	/**
	 * origin: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\gui\ScrollBarUI.java
	 */

class ScrollBarUI extends MetalScrollBarUI {
    
    private static final Dimension DIMENSIONS_EMPTY = new Dimension(0, 0);
    
    private static final Color COLOR_UI_BACKGROUND = Color.decode("#272822");
    
    private static final int OFFSET_HEIGHT_THUMB = 1;
    private static final int OFFSET_WIDTH_THUMB = 2;
    private Image imageThumb, imageTrack;

    ScrollBarUI() {
	loadUiGraphics();
    }

    public void loadUiGraphics() {
	BufferedGraphics graphics = new BufferedGraphics();
	imageThumb = graphics.getThumb();
	imageTrack = graphics.getTrack();
    }

    @Override
    protected void paintThumb(Graphics g, JComponent c, Rectangle thumbBounds) {
	g.translate(thumbBounds.x, thumbBounds.y);
	g.setColor(COLOR_UI_BACKGROUND);
	
	g.drawRect(0, 0, thumbBounds.width - OFFSET_WIDTH_THUMB, thumbBounds.height - OFFSET_HEIGHT_THUMB);
	
	AffineTransform transform = AffineTransform.getScaleInstance(calculateThumbWidth(thumbBounds),calculateThumbHeight(thumbBounds));
	((Graphics2D)g).drawImage(imageThumb, transform, null);
	g.translate( -thumbBounds.x, -thumbBounds.y ); 
    }

    public double calculateThumbHeight(Rectangle thumbBounds) {
	return (double)thumbBounds.height/imageThumb.getHeight(null);
    }

    public double calculateThumbWidth(Rectangle thumbBounds) {
	return (double)thumbBounds.width/imageThumb.getWidth(null);
    }

    @Override
    protected void paintTrack(Graphics g, JComponent c, Rectangle trackBounds) {
	g.translate(trackBounds.x, trackBounds.y);
	((Graphics2D)g).drawImage(imageTrack,AffineTransform.getScaleInstance(1,(double)trackBounds.height/imageTrack.getHeight(null)),null);
	g.translate( -trackBounds.x, -trackBounds.y );
    }

    //Remove ugly arrows buttons:
    @Override
    protected JButton createDecreaseButton(int orientation) {
	return createZeroButton();
    }

    @Override    
    protected JButton createIncreaseButton(int orientation) {
	return createZeroButton();
    }

    private JButton createZeroButton() {
	JButton jbutton = new JButton();
	jbutton.setPreferredSize(DIMENSIONS_EMPTY);
	jbutton.setMinimumSize(DIMENSIONS_EMPTY);
	jbutton.setMaximumSize(DIMENSIONS_EMPTY);
	return jbutton;
    }

}
	// End of segment: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\gui\ScrollBarUI.java





	/**
	 * origin: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\gui\SettingsPane.java
	 */

public class SettingsPane extends JFrame {

    private static final Rectangle BOUNDS_DEFAULT_COLLATES_LABEL = new Rectangle(640, 45, 201, 16);
    private static final Rectangle BOUNDS_MAIN_TITLE = new Rectangle(369, 17, 182, 25);
    private static final Rectangle BOUNDS_CANCEL_BUTTON = new Rectangle(0, 366, 81, 34);
    private static final Rectangle BOUNDS_ACTIVE_FEEDBACK_CHECKBOX = new Rectangle(170, 40, 25, 25);
    private static final Rectangle BOUNDS_COMM_PANE = new Rectangle(45, 195, 396, 155);
    private static final Rectangle BOUNDS_PARA_PANE = new Rectangle(490, 195, 396, 155);
    private static final Rectangle BOUNDS_SAVE_BUTTON = new Rectangle(839, 366, 81, 34);
    private static final Rectangle BOUNDS_DEFAULT_FOLDER_SELECTOR = new Rectangle(75, 116, 97, 27);
    private static final Rectangle BOUNDS_FOLDER_LABEL = new Rectangle(70, 81, 780, 60);
    private static final Rectangle BOUNDS_FEEDBACK_CHECKBOX_LABEL = new Rectangle(21, 45, 157, 16);
    private static final Rectangle BOUNDS_COMM_TITLE = new Rectangle(130, 165, 201, 16);
    private static final Rectangle BOUNDS_PARA_TITLE = new Rectangle(588, 167, 201, 16);
    private static final Rectangle BOUNDS_WARNING_LABEL = new Rectangle(110, 364, 700, 28);
    private static final Rectangle BOUNDS_COMMAND_KEYWORD_PANE = new Rectangle(34, 195, 396, 155);
    private static final Rectangle BOUNDS_PARA_KEYWORD_PANE = BOUNDS_PARA_PANE;
    
    private static final Logger logger = Controller.getLogger();
    
    private static final Dimension DIMENSIONS_KEYWORD_BAR_PREFERRED_SIZE = new Dimension(396, 41);
    private static final Dimension DIMENSIONS_SETTINGS_PANE = new Dimension(920, 400);

    private static final String FILENAME_CONFIG_FILE = "Config.cfg";
    private static final String BOOLEAN_REF_DEFAULT_COLLATED = "isDefaultCollated";
    private static final String BOOLEAN_REF_FEEDBACK_ENABLED = "isActiveFeedbackEnabled";
    
    private static final String MESSAGE_INVALID_FOLDER_NAME = "Please specify a shorter name for Folder %1$s or check that it's not empty";
    private static final String MESSAGE_DUPLICATE_FOLDER_NAME = "Folder %1$s's name is a duplicate";
    private static final String MESSAGE_SAVE_FAILED = "SAVE FAILED: ";
    private static final String MESSAGE_CONFIG_WRITE_FAILED = "Could not write config file";
    
    private static final ImageIcon ICON_CANCEL_BUTTON = new ImageIcon(MainInterface.class.getResource("/GUI Graphics/Settings Cancel Button.png"));
    private static final ImageIcon LABEL_FOLDER_SELECTION = new ImageIcon(MainInterface.class.getResource("/GUI Graphics/Settings Folder Display.png"));
    private static final ImageIcon ICON_SAVE_BUTTON = new ImageIcon(MainInterface.class.getResource("/GUI Graphics/Settings Save Button.png"));
    
    private static final String TITLE_PREFERENCES = "PREFERENCES";
    private static final String TITLE_ACTIVE_FEEDBACK = "Active Input Feedback";
    private static final String TITLE_DEFAULT_COLLATES = "Default Folder collates tasks";
    private static final String TITLE_COMMANDS = "COMMANDS";
    private static final String TITLE_PARAMETERS = "PARAMETERS";

    private static final int MAX_ROW_COUNT = 5;
    private static final int SCROLL_SPEED_PIXELS = 1;
    private static final int SCROLL_THUMB_WIDTH = 16;
    
    private static final Border SETTINGS_EMPTY_BORDER = BorderFactory.createEmptyBorder(0, 0, 0, 0);
    
    private static final Rectangle BOUNDS_FOLDER5_FIELD = new Rectangle(714, 116, 138, 28);
    private static final Rectangle BOUNDS_FOLDER4_FIELD = new Rectangle(578, 116, 140, 28);
    private static final Rectangle BOUNDS_FOLDER3_FIELD = new Rectangle(444, 116, 138, 28);
    private static final Rectangle BOUNDS_FOLDER2_FIELD = new Rectangle(308, 116, 140, 28);
    private static final Rectangle BOUNDS_FOLDER1_FIELD = new Rectangle(171, 116, 141, 28);
    
    private static final int TOOLTIP_REF = 2;
    private static final int CONFIG_NAME_REF = 1;
    private static final int DISPLAY_NAME_REF = 0;
    
    private static final int VERTICAL_GAP_BETWEEN_KEYWORD_ITEMS = 13;
    
    private static final Color COLOR_UI_BACKGROUND = Color.decode("#272822");
    
    private static final int ID_INT_FOLDER5 = 5;
    private static final int ID_INT_FOLDER4 = 4;
    private static final int ID_INT_FOLDER3 = 3;
    private static final int ID_INT_FOLDER2 = 2;
    private static final int ID_INT_FOLDER1 = 1;
    private static final int MAX_FOLDER_NAME_LENGTH = 16;
    
    private static final int ARRAY_ID_FOLDER5 = 4;
    private static final int ARRAY_ID_FOLDER4 = 3;
    private static final int ARRAY_ID_FOLDER3 = 2;
    private static final int ARRAY_ID_FOLDER2 = 1;
    private static final int ARRAY_ID_FOLDER1 = 0;
    
    private static final String DEFAULT_FOLDER_ID_STRING = "default";
    private static final String FOLDER5_ID_STRING = "folder5";
    private static final String FOLDER4_ID_STRING = "folder4";
    private static final String FOLDER3_ID_STRING = "folder3";
    private static final String FOLDER2_ID_STRING = "folder2";
    private static final String FOLDER1_ID_STRING = "folder1";
    
    private static final String TITLELESS_JFRAME = "TitleLessJFrame";
    private static final long serialVersionUID = 1L;

    
    private int dragPosX = 0, dragPosY = 0;
    private Checkbox activeFeedbackCheckbox, defaultCollatedCheckbox;
    private Config cfg;
    private String folder1Name, folder2Name, folder3Name, folder4Name, folder5Name, defaultFolder;
    
    private JComboBox<Object> defaultFolderSelector;
    private Properties props;
    
    private FolderNameField folder1Field;
    private FolderNameField folder2Field;
    private FolderNameField folder3Field;
    private FolderNameField folder4Field;
    private FolderNameField folder5Field;
    
    @SuppressWarnings("unused") // Compiler problem
    private Interpreter interpreter;
    private JLabel warningLabel;
    private JScrollPane commandKeywordPane, paraKeywordPane;
    
    private ArrayList<KeywordItem> commandKeywordItems = new ArrayList<KeywordItem>();
    private ArrayList<KeywordItem> paraKeywordItems = new ArrayList<KeywordItem>();

    private String[][] commandDatabase = new String[][]{
	    {"Add","add","How to use <>"},
	    {"Delete","delete","How to use <>"},
	    {"Clear Completed","clearCompleted","How to use <>"},
	    {"Clear", "clear","How to use <>"},
	    {"Modify", "modify","How to use <>"},
	    {"Mark", "mark","How to use <>"},
	    {"Unmark", "unmark","How to use <>"},
	    {"Search", "search","How to use <>"},
	    {"Now", "now","How to use <>"},
	    {"Today", "today","How to use <>"},
	    {"Tomorrow", "tomorrow","How to use <>"},
	    {"Week", "week","How to use <>"},
	    {"Month", "month","How to use <>"},
	    {"Undo", "undo","How to use <>"},
	    {"Redo", "redo","How to use <>"},
	    {"Show All", "displayAll","How to use <>"},
	    {"Non-Timed Tasks", "displayFloat","How to use <>"},
	    {"Show in Time", "display","How to use <>"},
	    {"Export", "export","How to use <>"},
	    {"Import", "import","How to use <>"},
	    {"Quit", "quit","How to use <>"}
    };
    
    private String[][] parameterDatabase = new String[][] {
	    {"Start Time","startTime","How to use <>"},
	    {"End Time", "endTime","How to use <>"},
	    {"Reminder Time", "reminderTime","How to use <>"},
	    {"Priority", "priority","How to use <>"},
	    {"Location", "location","How to use <>"},
	    {"Folder", "folder","How to use <>"},
	    {"Task ID", "taskID","How to use <>"}
    };
    
    public SettingsPane(JFrame mainFrame, Interpreter interpreter, Config cfg) {
	super(TITLELESS_JFRAME);
	loadFrameSettings(mainFrame);
	linkMainInterfaceComponents(interpreter, cfg);
	
	activateWindowDrag();
	
	loadFolderDatabase();
	loadGuiComponents();
	loadKeywordDatabase();
	setVisible(true);
    }

    private void linkMainInterfaceComponents(Interpreter interpreter, Config cfg) {
	MainInterface.getSettingsBtn().setEnabled(false);
	
	this.cfg = cfg;
	this.interpreter = interpreter;
    }
    
    private int getCurrentDefaultFolder(String folderId) {
	if (folderId.equals(FOLDER1_ID_STRING)) {
	    return ARRAY_ID_FOLDER1;
	} else if (folderId.equals(FOLDER2_ID_STRING)) {
	    return ARRAY_ID_FOLDER2;
	} else if (folderId.equals(FOLDER3_ID_STRING)) {
	    return ARRAY_ID_FOLDER3;
	} else if (folderId.equals(FOLDER4_ID_STRING)) {
	    return ARRAY_ID_FOLDER4;
	} else {
	    return ARRAY_ID_FOLDER5;
	}
    }
    
    private void loadFolderDatabase() {
	props = cfg.getConfigFile();
	
	defaultFolder = props.getProperty(DEFAULT_FOLDER_ID_STRING);
	folder1Name = props.getProperty(FOLDER1_ID_STRING);
	folder2Name = props.getProperty(FOLDER2_ID_STRING);
	folder3Name = props.getProperty(FOLDER3_ID_STRING);
	folder4Name = props.getProperty(FOLDER4_ID_STRING);
	folder5Name = props.getProperty(FOLDER5_ID_STRING);
    }


    private void activateWindowDrag() {
	addMouseListener(new MouseAdapter()
	{
	    public void mousePressed(MouseEvent e)
	    {
		dragPosX=e.getX();
		dragPosY=e.getY();
	    }
	});

	addMouseMotionListener(new MouseAdapter()
	{
	    public void mouseDragged(MouseEvent evt)
	    {		
		setLocation (evt.getXOnScreen()-dragPosX,evt.getYOnScreen()-dragPosY);

	    }
	});
    }

    private void loadKeywordDatabase() {
	
	loadCommands();
	loadParameters();
	
    }

    private void loadParameters() {
	
	paraKeywordItems.clear();
	
	JPanel paraPanel = new JPanel(new GridLayout(parameterDatabase.length, 0, 0, VERTICAL_GAP_BETWEEN_KEYWORD_ITEMS));
	
	paraPanel.setBackground(COLOR_UI_BACKGROUND);
	
	for (int i=0; i<parameterDatabase.length; i++) {
	    addParameterKeywordItem(paraPanel, i);
	}

	loadParameterKeywordPaneSettings(paraPanel);
    }

    private void loadCommands() {
	
	commandKeywordItems.clear();
	
	JPanel commandPanel = new JPanel(new GridLayout(commandDatabase.length, 0, 0, VERTICAL_GAP_BETWEEN_KEYWORD_ITEMS));

	commandPanel.setBackground(COLOR_UI_BACKGROUND);
	
	for (int i=0; i<commandDatabase.length; i++) {
	    addCommandKeywordItem(commandPanel, i);
	}
	
	loadCommandKeywordPaneSettings(commandPanel);
    }

    private void loadParameterKeywordPaneSettings(JPanel paraPanel) {
	paraKeywordPane.setBounds(BOUNDS_PARA_KEYWORD_PANE);
	paraKeywordPane.setViewportView(paraPanel);
	paraKeywordPane.setVisible(true);
    }

    private void addParameterKeywordItem(JPanel paraPanel, int i) {
	KeywordItem keywordBar = new KeywordItem(parameterDatabase[i][DISPLAY_NAME_REF], cfg.getProperty(parameterDatabase[i][CONFIG_NAME_REF]));
	
	keywordBar.setPreferredSize(DIMENSIONS_KEYWORD_BAR_PREFERRED_SIZE);
	keywordBar.setToolTipText(parameterDatabase[i][TOOLTIP_REF]); 
	keywordBar.setVisible(true);
	paraPanel.add(keywordBar);
	
	paraKeywordItems.add(keywordBar);
    }

    private void loadCommandKeywordPaneSettings(JPanel commandPanel) {
	commandKeywordPane.setBounds(BOUNDS_COMMAND_KEYWORD_PANE);
	commandKeywordPane.setViewportView(commandPanel);
	commandKeywordPane.setVisible(true);
    }

    private void addCommandKeywordItem(JPanel commandPanel, int i) {
	KeywordItem keywordBar = new KeywordItem(commandDatabase[i][DISPLAY_NAME_REF], cfg.getProperty(commandDatabase[i][CONFIG_NAME_REF]));

	keywordBar.setPreferredSize(DIMENSIONS_KEYWORD_BAR_PREFERRED_SIZE);
	keywordBar.setToolTipText(commandDatabase[i][TOOLTIP_REF]);
	keywordBar.setVisible(true);
	commandPanel.add(keywordBar);
	
	commandKeywordItems.add(keywordBar);
    }
    
    private void loadGuiComponents() {
	
	addCancelButton();    
	addSaveButton();
	
	addFolderNameFields();
	addCheckBoxes();
	
	addCommandKeywordPane();
	addParaKeywordPane();
	
	addDefaultFolderSelector();
	
	addWarningLabel();
	addTitles();
		
    }

    private void addWarningLabel() {
	warningLabel = new JLabel("");
	warningLabel.setForeground(Color.WHITE);
	warningLabel.setFont(MainInterface.latoBold16);
	warningLabel.setHorizontalAlignment(SwingConstants.CENTER);
	warningLabel.setBounds(BOUNDS_WARNING_LABEL);
	getContentPane().add(warningLabel);
    }

    private void addTitles() {
	
	JLabel parameterKeywordsTitle = new JLabel(TITLE_PARAMETERS);
	parameterKeywordsTitle.setHorizontalAlignment(SwingConstants.CENTER);
	parameterKeywordsTitle.setForeground(Color.WHITE);
	parameterKeywordsTitle.setFont(MainInterface.latoReg14);
	parameterKeywordsTitle.setBounds(BOUNDS_PARA_TITLE);
	getContentPane().add(parameterKeywordsTitle);
	
	
	JLabel commandKeywordsTitle = new JLabel(TITLE_COMMANDS);
	commandKeywordsTitle.setForeground(Color.WHITE);
	commandKeywordsTitle.setHorizontalAlignment(SwingConstants.CENTER);
	commandKeywordsTitle.setFont(MainInterface.latoReg14);
	commandKeywordsTitle.setBounds(BOUNDS_COMM_TITLE);
	getContentPane().add(commandKeywordsTitle);
	
	JLabel activeInputFeedbackTitle = new JLabel(TITLE_ACTIVE_FEEDBACK);
	activeInputFeedbackTitle.setForeground(Color.WHITE);
	activeInputFeedbackTitle.setFont(MainInterface.latoReg13);
	activeInputFeedbackTitle.setHorizontalAlignment(SwingConstants.CENTER);
	activeInputFeedbackTitle.setBounds(BOUNDS_FEEDBACK_CHECKBOX_LABEL);
	getContentPane().add(activeInputFeedbackTitle);
	
	JLabel defaultCollatedTitle = new JLabel(TITLE_DEFAULT_COLLATES);
	defaultCollatedTitle.setForeground(Color.WHITE);
	defaultCollatedTitle.setFont(MainInterface.latoReg13);
	defaultCollatedTitle.setHorizontalAlignment(SwingConstants.RIGHT);
	defaultCollatedTitle.setBounds(BOUNDS_DEFAULT_COLLATES_LABEL);
	getContentPane().add(defaultCollatedTitle);
	
	JLabel folderSelectionBackgroundLabel = new JLabel(LABEL_FOLDER_SELECTION);
	folderSelectionBackgroundLabel.setBounds(BOUNDS_FOLDER_LABEL);
	getContentPane().add(folderSelectionBackgroundLabel);
    }

    private void addDefaultFolderSelector() {
	
	defaultFolderSelector = new JComboBox<Object>();
	defaultFolderSelector.setFocusable(false);
	defaultFolderSelector.setFont(MainInterface.latoReg13);
	defaultFolderSelector.setModel(new DefaultComboBoxModel<Object>(new String[] {FOLDER1_ID_STRING, FOLDER2_ID_STRING, FOLDER3_ID_STRING, FOLDER4_ID_STRING, FOLDER5_ID_STRING}));
	defaultFolderSelector.setSelectedIndex(getCurrentDefaultFolder(defaultFolder));
	defaultFolderSelector.setMaximumRowCount(MAX_ROW_COUNT);
	defaultFolderSelector.setBounds(BOUNDS_DEFAULT_FOLDER_SELECTOR);
	getContentPane().add(defaultFolderSelector);
	
    }

    private void addSaveButton() {
	JButton btnSave = new JButton(ICON_SAVE_BUTTON);

	btnSave.setBounds(BOUNDS_SAVE_BUTTON);
	btnSave.setContentAreaFilled(false);
	btnSave.setBorder(SETTINGS_EMPTY_BORDER);
	btnSave.addActionListener(new ActionListener() {
	    public void actionPerformed(ActionEvent e) {
		saveChanges();
	    }
	});    

	getContentPane().add(btnSave);
    }

    private void addParaKeywordPane() {
	
	paraKeywordPane = new JScrollPane();
	paraKeywordPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
	paraKeywordPane.setBounds(BOUNDS_PARA_PANE);
	paraKeywordPane.setOpaque(false);
	paraKeywordPane.setBorder(SETTINGS_EMPTY_BORDER);
	paraKeywordPane.getViewport().setOpaque(false);
	paraKeywordPane.setOpaque(false);
	paraKeywordPane.setVisible(true);
	paraKeywordPane.setDoubleBuffered(true);

	addScrollBar(paraKeywordPane);

	paraKeywordPane.getVerticalScrollBar().setUnitIncrement(SCROLL_SPEED_PIXELS);
	
	getContentPane().add(paraKeywordPane);
    }

    private void addCommandKeywordPane() {
	
	commandKeywordPane = new JScrollPane();
	commandKeywordPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
	commandKeywordPane.setBounds(BOUNDS_COMM_PANE);
	commandKeywordPane.setOpaque(false);
	commandKeywordPane.setBorder(SETTINGS_EMPTY_BORDER);
	commandKeywordPane.getViewport().setOpaque(false);
	commandKeywordPane.setOpaque(false);
	commandKeywordPane.setVisible(true);
	commandKeywordPane.setDoubleBuffered(true);

	addScrollBar(commandKeywordPane);
	commandKeywordPane.getVerticalScrollBar().setUnitIncrement(SCROLL_SPEED_PIXELS);
	
	getContentPane().add(commandKeywordPane);
    }

    private void addScrollBar(JScrollPane scrollPane) {
	JScrollBar mainScrollBar = scrollPane.getVerticalScrollBar();
	mainScrollBar.setPreferredSize(new Dimension(SCROLL_THUMB_WIDTH, Integer.MAX_VALUE));
	mainScrollBar.setUI(new ScrollBarUI());
    }

    private void addCheckBoxes() {
	
	activeFeedbackCheckbox = new Checkbox("");
	activeFeedbackCheckbox.setFocusable(false);
	activeFeedbackCheckbox.setState(cfg.getIsActiveFeedbackEnabled());
	activeFeedbackCheckbox.setBackground(COLOR_UI_BACKGROUND);
	activeFeedbackCheckbox.setBounds(BOUNDS_ACTIVE_FEEDBACK_CHECKBOX);
	getContentPane().add(activeFeedbackCheckbox);
	
	
	defaultCollatedCheckbox = new Checkbox("");
	defaultCollatedCheckbox.setFocusable(false);
	defaultCollatedCheckbox.setState(cfg.getIsDefaultCollated());
	defaultCollatedCheckbox.setBackground(COLOR_UI_BACKGROUND);
	defaultCollatedCheckbox.setBounds(new Rectangle(846, 40, 25, 25));
	getContentPane().add(defaultCollatedCheckbox);
    }

    private void addFolderNameFields() {
	folder1Field = new FolderNameField(BOUNDS_FOLDER1_FIELD, folder1Name, this);
	folder2Field = new FolderNameField(BOUNDS_FOLDER2_FIELD, folder2Name, this);
	folder3Field = new FolderNameField(BOUNDS_FOLDER3_FIELD, folder3Name, this);
	folder4Field = new FolderNameField(BOUNDS_FOLDER4_FIELD, folder4Name, this);
	folder5Field = new FolderNameField(BOUNDS_FOLDER5_FIELD, folder5Name, this);
    }

    private void addCancelButton() {
	JButton btnCancel = new JButton(ICON_CANCEL_BUTTON);
	
	btnCancel.setBounds(BOUNDS_CANCEL_BUTTON);
	btnCancel.setContentAreaFilled(false);
	btnCancel.setBorder(BorderFactory.createEmptyBorder());
	btnCancel.addActionListener(new ActionListener() {
	    public void actionPerformed(ActionEvent e) {
		executeQuit();
	    }
	});
	
	getContentPane().add(btnCancel);
    }
    
    private void loadFrameSettings(JFrame mainFrame) {
	setBackground(COLOR_UI_BACKGROUND);
	
	getContentPane().setBackground(COLOR_UI_BACKGROUND);
	setAlwaysOnTop(true);
	setLocationByPlatform(true);
	
	getContentPane().setLayout(null);
	
	addMainTitle();
	
	setLocationRelativeTo(mainFrame); 
	
	setResizable(false); 
	setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    }

    private void addMainTitle() {
	JLabel title = new JLabel(TITLE_PREFERENCES);
	title.setForeground(Color.WHITE);
	title.setFont(MainInterface.latoBold20);//new Font("Lato", Font.BOLD, 20));
	title.setHorizontalAlignment(SwingConstants.CENTER);
	title.setBounds(BOUNDS_MAIN_TITLE);
	getContentPane().add(title);
	setUndecorated(true); 
	setSize(DIMENSIONS_SETTINGS_PANE);
    }


    private void executeQuit() {
	MainInterface.getSettingsBtn().setEnabled(true);
	
	cfg = new Config();
	interpreter = new Interpreter(true);
	
	dispose();
    }
    
    private void checkKeywordDatabase() throws IllegalArgumentException {
	Properties checkPropDuplicate = new Properties();
	
	for (int i=0; i<commandKeywordItems.size(); i++) {
	    checkPropDuplicate.setProperty(commandDatabase[i][CONFIG_NAME_REF], commandKeywordItems.get(i).getInputText());
	}
	
	for (int i=0; i<paraKeywordItems.size(); i++) {
	    checkPropDuplicate.setProperty(parameterDatabase[i][CONFIG_NAME_REF], paraKeywordItems.get(i).getInputText());
	}
	
	new Interpreter(checkPropDuplicate);
	
	props = checkPropDuplicate;
    }
    
    private void saveKeywordDatabase() throws IllegalArgumentException {
	try {
	    checkKeywordDatabase();
	} catch (IllegalArgumentException e) {
	    logger.log(Level.WARNING, e.getMessage());
	    throw new IllegalArgumentException(e.getMessage());
	}
	
    }
    
    private void saveChanges() {

	
	try {
		saveKeywordDatabase();
		saveFolderSettings();
		saveCheckBoxes();
		
		// If no exceptions were found:
		writeToConfigFile();
		
		refreshMainInterface();
		executeQuit();
	} catch (IllegalArgumentException exceptionFeedback) {
	    warningLabel.setText(MESSAGE_SAVE_FAILED + exceptionFeedback.getMessage());
	}
    }

    private void saveCheckBoxes() {
	props.setProperty(BOOLEAN_REF_FEEDBACK_ENABLED, Boolean.toString(activeFeedbackCheckbox.getState()));
	props.setProperty(BOOLEAN_REF_DEFAULT_COLLATED, Boolean.toString(defaultCollatedCheckbox.getState()));
    }

    private void refreshMainInterface() {
	MainInterface.loadAllFolderLabels();
	MainInterface.updateAllFolderLabels();
	MainInterface.updateTaskDisplay();
    }
    
    private boolean isValidNameSize(String name) {
	return name.length() < MAX_FOLDER_NAME_LENGTH;
    }
    
    private void checkValidityOfFolderNames() throws IllegalArgumentException {
	if (isValidFolderName(folder1Field)) {
	    throw new IllegalArgumentException(String.format(MESSAGE_INVALID_FOLDER_NAME, ID_INT_FOLDER1));
	} else if (isValidFolderName(folder2Field)) {
	    throw new IllegalArgumentException(String.format(MESSAGE_INVALID_FOLDER_NAME, ID_INT_FOLDER2));
	} else if (isValidFolderName(folder3Field)) {
	    throw new IllegalArgumentException(String.format(MESSAGE_INVALID_FOLDER_NAME, ID_INT_FOLDER3));
	} else if (isValidFolderName(folder4Field)) {
	    throw new IllegalArgumentException(String.format(MESSAGE_INVALID_FOLDER_NAME, ID_INT_FOLDER4));
	} else if (isValidFolderName(folder5Field)) {
	    throw new IllegalArgumentException(String.format(MESSAGE_INVALID_FOLDER_NAME, ID_INT_FOLDER5));
	} 
	
	return;
    }

    private boolean isValidFolderName(FolderNameField nameField) {
	return !isValidNameSize(nameField.getText()) || nameField.getText().trim().isEmpty();
    }
    
    private void saveFolderProps() {
	defaultFolder = (String) defaultFolderSelector.getSelectedItem();
	props.setProperty(DEFAULT_FOLDER_ID_STRING, defaultFolder);
	
	props.setProperty(FOLDER1_ID_STRING, folder1Field.getText());
	props.setProperty(FOLDER2_ID_STRING, folder2Field.getText());
	props.setProperty(FOLDER3_ID_STRING, folder3Field.getText());
	props.setProperty(FOLDER4_ID_STRING, folder4Field.getText());
	props.setProperty(FOLDER5_ID_STRING, folder5Field.getText());
    }
    
    private void checkForDuplicateNames() throws IllegalArgumentException {
	ArrayList<String> currentNames = new ArrayList<String>();
	
	if (duplicateNameExists(currentNames, folder1Field)) {
	    currentNames.add(folder1Field.getText().toLowerCase());
	} else {
	    throw new IllegalArgumentException(String.format(MESSAGE_DUPLICATE_FOLDER_NAME, ID_INT_FOLDER1));
	}
	
	if (duplicateNameExists(currentNames, folder2Field)) {
	    currentNames.add(folder2Field.getText().toLowerCase());
	} else {
	    throw new IllegalArgumentException(String.format(MESSAGE_DUPLICATE_FOLDER_NAME, ID_INT_FOLDER2));
	}
	
	if (duplicateNameExists(currentNames, folder3Field)) {
	    currentNames.add(folder3Field.getText().toLowerCase());
	} else {
	    throw new IllegalArgumentException(String.format(MESSAGE_DUPLICATE_FOLDER_NAME, ID_INT_FOLDER3));
	}
	
	if (duplicateNameExists(currentNames, folder4Field)) {
	    currentNames.add(folder4Field.getText().toLowerCase());
	} else {
	    throw new IllegalArgumentException(String.format(MESSAGE_DUPLICATE_FOLDER_NAME, ID_INT_FOLDER4));
	}
	
	if (duplicateNameExists(currentNames, folder5Field)) {
	    currentNames.add(folder5Field.getText().toLowerCase());
	} else {
	    throw new IllegalArgumentException(String.format(MESSAGE_DUPLICATE_FOLDER_NAME, ID_INT_FOLDER5));
	}
	
    }

    private boolean duplicateNameExists(ArrayList<String> currentNames, FolderNameField folderName) {
	return !currentNames.contains(folderName.getText().toLowerCase());
    }
    
    private void saveFolderSettings() throws IllegalArgumentException {
	
	try {
		checkValidityOfFolderNames();
		checkForDuplicateNames();
		
	} catch (IllegalArgumentException e) {
	    throw new IllegalArgumentException(e.getMessage());
	}
	
	saveFolderProps();
	
    }

    private void writeToConfigFile() {
	try {
	    props.store(new FileOutputStream(FILENAME_CONFIG_FILE), null);
	} catch (FileNotFoundException e) {
	    logger.log(Level.SEVERE, MESSAGE_CONFIG_WRITE_FAILED + e.getStackTrace());
	} catch (IOException e) {
	    logger.log(Level.SEVERE,MESSAGE_CONFIG_WRITE_FAILED + e.getStackTrace());
	}
    }
    
}

	// End of segment: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\gui\SettingsPane.java





	/**
	 * origin: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\gui\TaskItem.java
	 */

public class TaskItem extends JLayeredPane {

    private static final int PROGRESS_BAR_UPDATE_PERIOD = 120000;
    private static final int MIN_WIDTH_PROGRESS_BAR = 0;
    private static final int MAX_WIDTH_PROGRESS_BAR = 762;
    private static final int HEIGHT_PROGRESS_BAR = 38;
    private static final Point LOCATION_PROGRESS_BAR = new Point(83, 1);
   
    private static final Dimension DIMENSIONS_PRIORITY_ICON = new Dimension(23, 20);
    private static final Dimension DIMENSIONS_INITIAL_PROGRESS_BAR = new Dimension(MIN_WIDTH_PROGRESS_BAR, HEIGHT_PROGRESS_BAR);
    private static final Dimension DIMENSIONS_TASK_ITEM = new Dimension(888, 40);
    private static final Dimension DIMENSIONS_DATE_ICON = new Dimension(25, 25);
    private static final Dimension DIMENSIONS_INFO_ICON = DIMENSIONS_DATE_ICON;
    private static final Dimension DIMENSIONS_ITEM_BACKGROUND = DIMENSIONS_TASK_ITEM;
    private static final Rectangle BOUNDS_TEXT_LABEL = new Rectangle(126, -2, 600, 42);
    private static final Rectangle BOUNDS_DELETE_ICON = new Rectangle(35, 3, 34, 34);
    private static final Rectangle BOUNDS_APPARENT_ID = new Rectangle(34, 2, 34, 34);
    
    private static final int YPOS_PRIORITY_ICON = 10;
    private static final int YPOS_TOGGLE_ICONS = 7;
    private static final int HEIGHT_ELLIPSIS = 42;
    
    private static final int MAX_DISPLAY_TEXT_LENGTH = 600;
    private static final int INT_PRIORITY_LOW = 3;
    private static final int INT_PRIORITY_MEDIUM = 2;
    private static final int INT_PRIORITY_HIGH = 1;
    private static final int INT_PRIORITY_NONE = 0;
    
    private static final String DATE_FORMAT_ENDED = "ended ";
    private static final String DATE_FORMAT_ENDS = "ends ";
    private static final String DATE_FORMAT_STARTS = "starts ";
    
    private static final String PRI_STRING_MEDIUM = "med";
    private static final String PRI_STRING_HIGH = "high";
    private static final String PRI_STRING_LOW = "low";
    
    private static final String EMPTY_LOCATION = "NIL";

    private static final String HTML_END_TAG_WITH_STRIKE = "</strike></html>";
    private static final String HTML_START_TAG_WITH_STRIKE = "<html><strike>";
    private static final String HTML_END_TAG = "</html>";
    private static final String HTML_START_TAG = "<html>";

    private static final String DEFAULT_DISPLAY_TEXT = "<html> Description – <font color='9a9695'>Time @ Location</font></html>";
    
    private static final String HTML_FLOATING_TASK = "<html><nobr><font color='f7bbbb'> %1$s</font> <font color='9a9695'>%2$s</font></nobr></html>";
    private static final String HTML_TIME_DISPLAY_WITH_REMINDER = "<html><nobr> Start: <font color='9a9695'>%1$s</font>End: <font color='9a9695'>%2$s</font>Reminder: <font color='9a9695'>%3$s</font></nobr></html>";
    private static final String HTML_TIME_DISPLAY = "<html><nobr> Start: <font color='9a9695'>%1$s</font>End: <font color='9a9695'>%2$s</font></nobr></html>";
    private static final String HTML_INFO_DISPLAY = "<html><nobr> %1$s&nbsp; – <font color='9a9695'>%2$s%3$s</font></nobr></html>";
    
    private static final String MESSAGE_OVERFLOW_ELLIPSIS = " ...";
    private static final String SINGLE_SPACE = " ";
    private static final String INPUT_DELIMITER = " -";
    private static final String DESCRIPTION_SEPERATION_HYPHEN = " – ";

    private static final Border SETTINGS_EMPTY_BORDER = BorderFactory.createEmptyBorder(0, 0, 0, 0);

    private static final long serialVersionUID = 1L;

    private static final String HTML_SPACING = "&nbsp;&nbsp;&nbsp;";
    private static final String PREFIX_AT_LOCATION = " @ ";
    
    private static final int DISPLAY_TIME_UPDATE_PERIOD = 60000; //milliseconds

    private static final int LEADING_XPOS_OFFSET = 82;
    private static final Rectangle BOUNDS_CHECK_MARK = new Rectangle(8 + LEADING_XPOS_OFFSET, 9, 23, 23);
    private static final Rectangle BOUNDS_UNCHECKED_MARK = BOUNDS_CHECK_MARK;
    private static final Rectangle BOUNDS_ELLIPSIS = new Rectangle(635 + LEADING_XPOS_OFFSET, 9, 40, 24);
    private static final int TRAILING_SPACE_OFFSET = 31;
    private static final Rectangle BOUNDS_REMINDER_ICON = new Rectangle(689 + 10 + LEADING_XPOS_OFFSET + TRAILING_SPACE_OFFSET, 7, 25, 26);
    private static final Point LOCATION_PRIORITY_ICON_INIT = new Point(666 + LEADING_XPOS_OFFSET + TRAILING_SPACE_OFFSET, 7);
    private static SimpleDateFormat dateFormatter = new SimpleDateFormat("dd MMM yyyy HH:mm");
    
    private static final int INT_DEFAULT_FOLDER = 0;
    private static final String STRING_DEFAULT_FOLDER = "default";

    public static PrettyTime prettyTimeParser = new PrettyTime();
    public static BufferedGraphics bufferedGraphics = new BufferedGraphics();

    private JLabel background;
    private JLabel checkMark;
    private JLabel reminderIcon;
    private JLabel priorityIcon;
    private JLabel text;
    private JLabel dateIcon;
    private JLabel infoIcon;
    private JLabel uncheckedMark;
    private JLabel ellipsis;
    private JLabel apparentId;
    private JLabel deleteIcon;
    
    private ProgressBar progressBar;

    private String description;
    private String location;
    private String infoDisplayTime, dateDisplayTime;
    private int guiId;
    private static Controller controller;
    private Calendar reminderTime;

    private boolean isFloatingTask = false;
    private boolean inDateDisplayState = false;

    private Task timedTask;
    private FloatingTask floatingTask;

    private int withoutReminderXPosOffset;

    private static Interpreter interpreter;
    private static JTextPane textPane;

    private ActionListener updateTime = new ActionListener() {
	public void actionPerformed(ActionEvent evt) {
	    if (!inDateDisplayState && !isFloatingTask) {
		setTimedDisplayText(description, location, formatInfoTimings());
	    }
	}
    };
    
    private ActionListener updateProgressBar = new ActionListener() {
	public void actionPerformed(ActionEvent evt) {
	    if (!isFloatingTask) {
		updateProgressBar();
	    }
	}
    };

    public TaskItem(JTextPane textPane, Controller controller, final int guiId, Interpreter interpreter) {

	super();
	linkMainInterfaceComponents(textPane, controller, guiId, interpreter);
	loadItemSettings(); 

	loadGuiComponents(guiId);
	
	addTaskItemBackground();
	addToggleIconMouseListener();
    }

    private void loadGuiComponents(final int guiId) {
	
	addCheckMark(guiId);
	addUncheckedMark(guiId);

	addDateIcon();
	addInfoIcon();

	addReminderIcon();
	addPriorityIcon();

	addOverflowEllipsis();
	addTextLabel();

	addDeleteIcon();
	addApparentTaskId();

    }

    private void addTaskItemBackground() {
	
	addStatusProgressBar();
	addDefaultPlainBackground();
	
    }

    private void addStatusProgressBar() {
	progressBar = new ProgressBar(0, 0); // initialize at coordinate {0, 0}. Location will be set later
	progressBar.setSize(DIMENSIONS_INITIAL_PROGRESS_BAR);
	progressBar.setLocation(LOCATION_PROGRESS_BAR);
	this.add(progressBar);
    }

    private void addDefaultPlainBackground() {
	background = new JLabel();
	background.setSize(DIMENSIONS_ITEM_BACKGROUND);
	background.setIcon(bufferedGraphics.getBackground());
	this.add(background);
    }

    private void addToggleIconMouseListener() {
	this.addMouseListener(new MouseAdapter() {
	    @Override
	    public void mouseEntered(MouseEvent e) {
		showDateInfoIcon();
	    }

	    @Override
	    public void mouseExited(MouseEvent e) {
		hideDateInfoIcon();
	    }

	});
    }

    private void addApparentTaskId() {
	apparentId = new JLabel("");
	apparentId.addMouseListener(new MouseAdapter() {
	    @Override
	    public void mouseClicked(MouseEvent e) {
		deleteTaskShortcut();
	    }
	    @Override
	    public void mouseEntered(MouseEvent e) {
		deleteIcon.setVisible(true);		    
	    }
	    @Override
	    public void mouseExited(MouseEvent e) {
		deleteIcon.setVisible(false);
	    }
	});
	apparentId.setHorizontalAlignment(SwingConstants.CENTER);
	apparentId.setFont(MainInterface.latoReg12); 
	apparentId.setForeground(Color.WHITE);
	apparentId.setBounds(BOUNDS_APPARENT_ID);
	this.add(apparentId);
    }

    private void addDeleteIcon() {
	deleteIcon = new JLabel();
	deleteIcon.setIcon(bufferedGraphics.getDelete());
	deleteIcon.setBounds(BOUNDS_DELETE_ICON);
	deleteIcon.setVisible(false);
	this.add(deleteIcon);
    }

    private void addTextLabel() {
	text = new JLabel("");
	text.setToolTipText("");
	text.addMouseListener(new MouseAdapter() {
	    @Override
	    public void mouseClicked(MouseEvent e) {
		modifyDescriptionShortcut();
	    }
	    @Override
	    public void mouseEntered(MouseEvent e) {
		showDateInfoIcon();
	    }

	    @Override
	    public void mouseExited(MouseEvent e) {
		hideDateInfoIcon();
	    }

	});
	text.setForeground(Color.WHITE);
	text.setFont(MainInterface.latoReg14);
	text.setBounds(BOUNDS_TEXT_LABEL);
	text.setText(DEFAULT_DISPLAY_TEXT);
	this.add(text);
    }

    private void addOverflowEllipsis() {
	ellipsis = new JLabel(MESSAGE_OVERFLOW_ELLIPSIS);
	ellipsis.setForeground(Color.WHITE);
	ellipsis.setFont(MainInterface.mesloReg16);
	ellipsis.setBounds(BOUNDS_ELLIPSIS);
	ellipsis.setVisible(false);
	add(ellipsis);
    }

    private void addPriorityIcon() {
	priorityIcon = new JLabel();
	priorityIcon.addMouseListener(new MouseAdapter() {
	    @Override
	    public void mouseClicked(MouseEvent e) {
		if (isFloatingTask) {
		    cyclePriorities(floatingTask.getPriority());
		} else {
		    cyclePriorities(timedTask.getPriority());
		}
	    }
	});
	priorityIcon.setLocation(LOCATION_PRIORITY_ICON_INIT);
	priorityIcon.setVisible(false);
	this.add(priorityIcon);
    }

    private void addReminderIcon() {
	reminderIcon = new JLabel();
	reminderIcon.addMouseListener(new MouseAdapter() {
	    @Override
	    public void mouseClicked(MouseEvent e) {
		reminderShortcut();
	    }
	});
	reminderIcon.setBounds(BOUNDS_REMINDER_ICON);
	reminderIcon.setIcon(bufferedGraphics.getReminderIcon());
	reminderIcon.setVisible(false);
	this.add(reminderIcon);
    }

    private void addInfoIcon() {
	infoIcon = new JLabel();
	infoIcon.addMouseListener(new MouseAdapter() {
	    @Override
	    public void mouseClicked(MouseEvent e) {
		activateInfoState();
	    }

	    @Override
	    public void mouseEntered(MouseEvent e) {
		showDateInfoIcon();
	    }

	    @Override
	    public void mouseExited(MouseEvent e) {
		hideDateInfoIcon();
	    }
	});
	infoIcon.setSize(DIMENSIONS_INFO_ICON);
	infoIcon.setIcon(bufferedGraphics.getInfo());
	infoIcon.setVisible(false);
	this.add(infoIcon);
    }

    private void addDateIcon() {
	dateIcon = new JLabel();
	dateIcon.addMouseListener(new MouseAdapter() {
	    @Override
	    public void mouseClicked(MouseEvent e) {
		activateDateState();
	    }
	    @Override
	    public void mouseEntered(MouseEvent e) {
		showDateInfoIcon();
	    }

	    @Override
	    public void mouseExited(MouseEvent e) {
		hideDateInfoIcon();
	    }
	});
	dateIcon.setSize(DIMENSIONS_DATE_ICON);
	dateIcon.setIcon(bufferedGraphics.getDate());
	dateIcon.setVisible(false);
	this.add(dateIcon);
    }

    private void addUncheckedMark(final int guiId) {
	uncheckedMark = new JLabel();
	uncheckedMark.addMouseListener(new MouseAdapter() {
	    @Override
	    public void mouseClicked(MouseEvent e) {
		executeCheck(guiId);
	    }
	    @Override
	    public void mouseEntered(MouseEvent e) {
		showDateInfoIcon();
	    }

	    @Override
	    public void mouseExited(MouseEvent e) {
		hideDateInfoIcon();
	    }
	});
	uncheckedMark.setBounds(BOUNDS_UNCHECKED_MARK);
	uncheckedMark.setIcon(bufferedGraphics.getUnchecked());
	uncheckedMark.setVisible(true);
	this.add(uncheckedMark);
    }

    private void addCheckMark(final int guiId) {
	checkMark = new JLabel();
	checkMark.addMouseListener(new MouseAdapter() {
	    @Override
	    public void mouseClicked(MouseEvent e) {
		executeUncheck(guiId);
	    }
	    @Override
	    public void mouseEntered(MouseEvent e) {
		showDateInfoIcon();
	    }

	    @Override
	    public void mouseExited(MouseEvent e) {
		hideDateInfoIcon();
	    }
	});
	checkMark.setBounds(BOUNDS_CHECK_MARK);
	checkMark.setIcon(bufferedGraphics.getCheckMark());
	checkMark.setVisible(false);
	this.add(checkMark);
    }

    private void loadItemSettings() {
	this.setSize(DIMENSIONS_TASK_ITEM);
	this.setBorder(SETTINGS_EMPTY_BORDER);

	new Timer(DISPLAY_TIME_UPDATE_PERIOD, updateTime).start();
	new Timer(PROGRESS_BAR_UPDATE_PERIOD, updateProgressBar).start();
    }

    private void linkMainInterfaceComponents(JTextPane textPane,
	    Controller controller, final int guiId, Interpreter interpreter) {
	TaskItem.textPane = textPane;
	TaskItem.controller = controller;
	TaskItem.interpreter = interpreter;
	this.guiId = guiId;
    }

    private void addStrikeThrough() {
	String currentHtmlString = text.getText();

	String stringWithStartTag = currentHtmlString.replace(HTML_START_TAG, HTML_START_TAG_WITH_STRIKE);
	String stringWithStartAndEndTag = stringWithStartTag.replace(HTML_END_TAG, HTML_END_TAG_WITH_STRIKE);

	text.setText(stringWithStartAndEndTag);
    }

    private void removeStrikeThrough() {
	String currentHtmlString = text.getText();

	String stringWithStartTag = currentHtmlString.replace(HTML_START_TAG_WITH_STRIKE, HTML_START_TAG);
	String stringWithStartAndEndTag = stringWithStartTag.replace(HTML_END_TAG_WITH_STRIKE, HTML_END_TAG);

	text.setText(stringWithStartAndEndTag);
    }

    private void activateInfoState() {

	inDateDisplayState = false;
	infoIcon.setVisible(false);
	dateIcon.setVisible(true);

	setTimedDisplayText(description, location, infoDisplayTime);
	placeEllipsis(description, location, infoDisplayTime);
    }

    private void activateDateState() {

	inDateDisplayState = true;
	dateIcon.setVisible(false);
	infoIcon.setVisible(true);

	text.setText(dateDisplayTime);
	ellipsis.setVisible(false);
    }

    private void reminderShortcut() {

	MainInterface.clearTextPane();
	String reminderTime = dateFormatter.format(this.reminderTime.getTime());

	textPane.replaceSelection(interpreter.getDefaultCommandSyn(CommandType.MODIFY) + INPUT_DELIMITER + interpreter.getDefaultParaSyn(ParameterType.TASK_ID) + SINGLE_SPACE + guiId + INPUT_DELIMITER + interpreter.getDefaultParaSyn(ParameterType.REMINDER_TIME) + SINGLE_SPACE + reminderTime);
    }

    private void deleteTaskShortcut() {	

	controller.executeCommands(interpreter.getDefaultCommandSyn(CommandType.DELETE) + INPUT_DELIMITER + interpreter.getDefaultParaSyn(ParameterType.TASK_ID) + SINGLE_SPACE + guiId); 
	refreshDisplay();

    }

    public void refreshDisplay() {
	MainInterface.updateTaskDisplay();
    }

    private void modifyDescriptionShortcut() {

	MainInterface.clearTextPane();

	if (isFloatingTask) {
	    generateFloatingTaskDetails(); 
	    return;
	}

	if (!inDateDisplayState) {
	    generateInfoDetails();
	} else {
	    generateTimeDetails();
	}
    }

    private void generateTimeDetails() {
	if (timedTask.getIsThereReminder()) {
	    textPane.replaceSelection(interpreter.getDefaultCommandSyn(CommandType.MODIFY) + INPUT_DELIMITER + interpreter.getDefaultParaSyn(ParameterType.TASK_ID) + SINGLE_SPACE + guiId + INPUT_DELIMITER + interpreter.getDefaultParaSyn(ParameterType.START_TIME) + SINGLE_SPACE + dateFormatter.format(timedTask.getStartTime().getTime()) + INPUT_DELIMITER + interpreter.getDefaultParaSyn(ParameterType.END_TIME) + SINGLE_SPACE
		    + dateFormatter.format(timedTask.getEndTime().getTime()) + INPUT_DELIMITER + interpreter.getDefaultParaSyn(ParameterType.REMINDER_TIME) + SINGLE_SPACE + dateFormatter.format(this.reminderTime.getTime()));
	} else {
	    textPane.replaceSelection(interpreter.getDefaultCommandSyn(CommandType.MODIFY) + INPUT_DELIMITER + interpreter.getDefaultParaSyn(ParameterType.TASK_ID) + SINGLE_SPACE + guiId + INPUT_DELIMITER + interpreter.getDefaultParaSyn(ParameterType.START_TIME) + SINGLE_SPACE + dateFormatter.format(timedTask.getStartTime().getTime()) + INPUT_DELIMITER + interpreter.getDefaultParaSyn(ParameterType.END_TIME) + SINGLE_SPACE 
		    + dateFormatter.format(timedTask.getEndTime().getTime()));
	}
    }

    private void generateInfoDetails() {
	String location = "";
	if (!timedTask.getLocation().equals(EMPTY_LOCATION)) {
	    location = INPUT_DELIMITER + interpreter.getDefaultParaSyn(ParameterType.LOCATION) + SINGLE_SPACE + timedTask.getLocation();
	}

	textPane.replaceSelection(interpreter.getDefaultCommandSyn(CommandType.MODIFY) + SINGLE_SPACE + timedTask.getTaskTitle() + INPUT_DELIMITER + interpreter.getDefaultParaSyn(ParameterType.TASK_ID) + SINGLE_SPACE + guiId + location + SINGLE_SPACE);
    }

    private void generateFloatingTaskDetails() {
	String location = "";

	if (!floatingTask.getLocation().equals(EMPTY_LOCATION)) {
	    location = INPUT_DELIMITER + interpreter.getDefaultParaSyn(ParameterType.LOCATION) + SINGLE_SPACE + floatingTask.getLocation();
	}

	textPane.replaceSelection(interpreter.getDefaultCommandSyn(CommandType.MODIFY) + SINGLE_SPACE + floatingTask.getTaskTitle() + INPUT_DELIMITER + interpreter.getDefaultParaSyn(ParameterType.TASK_ID) + SINGLE_SPACE + guiId + location + SINGLE_SPACE);
    }

    private void cyclePriorities(int currentPriority) {
	
	String currentFolder = getTaskFolder();
	
	switch(currentPriority) {
	case 0:
	    return;
	case 1:
	    controller.executeCommands(interpreter.getDefaultCommandSyn(CommandType.MODIFY) + INPUT_DELIMITER + interpreter.getDefaultParaSyn(ParameterType.TASK_ID) + SINGLE_SPACE + guiId + INPUT_DELIMITER + interpreter.getDefaultParaSyn(ParameterType.PRIORITY) + SINGLE_SPACE + PRI_STRING_LOW + SINGLE_SPACE + INPUT_DELIMITER + interpreter.getDefaultParaSyn(ParameterType.FOLDER) + SINGLE_SPACE + currentFolder);
	    break;
	case 2:
	    controller.executeCommands(interpreter.getDefaultCommandSyn(CommandType.MODIFY) + INPUT_DELIMITER + interpreter.getDefaultParaSyn(ParameterType.TASK_ID) + SINGLE_SPACE + guiId + INPUT_DELIMITER + interpreter.getDefaultParaSyn(ParameterType.PRIORITY) + SINGLE_SPACE + PRI_STRING_HIGH + SINGLE_SPACE + INPUT_DELIMITER + interpreter.getDefaultParaSyn(ParameterType.FOLDER) + SINGLE_SPACE + currentFolder);
	    break;
	case 3:
	    controller.executeCommands(interpreter.getDefaultCommandSyn(CommandType.MODIFY) + INPUT_DELIMITER + interpreter.getDefaultParaSyn(ParameterType.TASK_ID) + SINGLE_SPACE + guiId + INPUT_DELIMITER + interpreter.getDefaultParaSyn(ParameterType.PRIORITY) + SINGLE_SPACE + PRI_STRING_MEDIUM + SINGLE_SPACE + INPUT_DELIMITER + interpreter.getDefaultParaSyn(ParameterType.FOLDER) + SINGLE_SPACE + currentFolder);
	    break;
	}

	refreshDisplay();

    }

    private String getTaskFolder() {
	Config cfg = new Config();
	
	String currentFolder = MainInterface.getCurrentFolderName(); // fall-back folder
	
	if (!isFloatingTask) {
	    currentFolder = getTimedTaskFolder(cfg);
	} else {
	    currentFolder = getFloatingTaskFolder(cfg);
	}
	return currentFolder;
    }

    private String getFloatingTaskFolder(Config cfg) {
	String currentFolder;
	
	if (floatingTask.getFolder() != INT_DEFAULT_FOLDER) {
	    currentFolder =  cfg.getFolderName(cfg.getFolderId(floatingTask.getFolder()));
	} else {
	    currentFolder = STRING_DEFAULT_FOLDER;
	}
	
	return currentFolder;
    }

    private String getTimedTaskFolder(Config cfg) {
	String currentFolder;
	
	if (timedTask.getFolder() != INT_DEFAULT_FOLDER) {
	    currentFolder = cfg.getFolderName(cfg.getFolderId(timedTask.getFolder()));
	} else {
	    currentFolder = STRING_DEFAULT_FOLDER;
	}
	
	return currentFolder;
    }

    public void loadTimedTaskDetails(Task item, int guiId, Calendar reminderTime) {

	timedTask = item;

	assert (timedTask != null);

	loadTimedTaskGuiSettings(reminderTime);
	initializeTimedDisplayTexts();
	loadDisplayTime();

	setTimedDisplayText(description, location, infoDisplayTime);
	setCheckMark(timedTask.getIsTaskDone());

	setReminderIcon(timedTask.getIsThereReminder());
	setPriorityIcon(timedTask.getPriority(), timedTask.getIsThereReminder());

	setTaskStrikethrough(timedTask);
	setToggleButtonPos();
	
	updateProgressBar();	
    }
    
    private void updateProgressBar() {
	progressBar.setSize(computeProgressBarWidth(timedTask.getStartTime().getTimeInMillis(), timedTask.getEndTime().getTimeInMillis()), HEIGHT_PROGRESS_BAR);		
    }
    
    public static int computeProgressBarWidth(Long startMillis, Long endMillis) {
	
	long millisNow = System.currentTimeMillis();
	
	if (startMillis >= endMillis || millisNow >= endMillis) {
	    return MAX_WIDTH_PROGRESS_BAR;
	}
	
	if (millisNow <= startMillis) {
	    return MIN_WIDTH_PROGRESS_BAR; 
	}
	
	return (int) (MAX_WIDTH_PROGRESS_BAR - ((endMillis - millisNow) * MAX_WIDTH_PROGRESS_BAR / (endMillis - startMillis)));
    }

    private void setToggleButtonPos() {
	int xPosOfToggleBtn = calculateToggleBtnXPos();
	dateIcon.setLocation(xPosOfToggleBtn, YPOS_TOGGLE_ICONS);
	infoIcon.setLocation(xPosOfToggleBtn, YPOS_TOGGLE_ICONS);
    }

    private void setTaskStrikethrough(Task timedTask) {
	if (timedTask.getIsTaskDone()) {
	    addStrikeThrough();
	} else {
	    removeStrikeThrough();
	}
    }

    private void setTaskStrikethrough(FloatingTask floatingTask) {
	if (floatingTask.getIsTaskDone()) {
	    addStrikeThrough();
	} else {
	    removeStrikeThrough();
	}
    }

    private void loadDisplayTime() {
	infoDisplayTime = formatInfoTimings();

	if (timedTask.getIsThereReminder()) {
	    dateDisplayTime = updateDateTimings(timedTask.getStartTime(), timedTask.getEndTime(), this.reminderTime); 
	} else {
	    dateDisplayTime = updateDateTimings(timedTask.getStartTime(), timedTask.getEndTime());
	}
    }

    private void initializeTimedDisplayTexts() {

	description = timedTask.getTaskTitle();
	location = timedTask.getLocation();
	infoDisplayTime = "";

	if (location.equals(EMPTY_LOCATION)) {
	    location = "";
	} else {
	    location = PREFIX_AT_LOCATION + location;
	}

	apparentId.setText(guiId + "");
    }

    private void loadTimedTaskGuiSettings(Calendar reminderTime) {
	this.reminderTime = reminderTime;
	isFloatingTask = false;

	reminderIcon.setEnabled(true);
	infoIcon.setEnabled(true);
	dateIcon.setEnabled(true);
    }

    public void loadFloatingTaskDetails(FloatingTask item, int guiId) {

	floatingTask = item;

	assert(floatingTask != null);

	loadFloatingTaskGuiSettings();
	loadFloatingTaskDisplayText();

	setCheckMark(floatingTask.getIsTaskDone());
	setPriorityIcon(floatingTask.getPriority(), false);
	
	// Note: floating task currently doesn't support reminders
    }	

    private void loadFloatingTaskDisplayText() {
	String description = floatingTask.getTaskTitle();
	String location = "";

	if (floatingTask.getLocation().equals(EMPTY_LOCATION)) {
	    location = "";
	} else {
	    location = PREFIX_AT_LOCATION + floatingTask.getLocation();
	}

	String displayText = String.format(HTML_FLOATING_TASK, description, location);
	text.setText(displayText);

	setTaskStrikethrough(floatingTask);
    }

    private void loadFloatingTaskGuiSettings() {
	isFloatingTask = true;

	this.remove(reminderIcon);
	this.remove(infoIcon);
	this.remove(dateIcon);

	apparentId.setText(guiId + "");
    }

    private String updateDateTimings(Calendar startTime, Calendar endTime, Calendar remindTime) {

	String displayText = "";

	String startTimeString = dateFormatter.format(startTime.getTime()) + HTML_SPACING;
	String endTimeString = dateFormatter.format(endTime.getTime()) + HTML_SPACING;
	String remindTimeString = dateFormatter.format(remindTime.getTime());

	displayText = String.format(HTML_TIME_DISPLAY_WITH_REMINDER, startTimeString, endTimeString, remindTimeString);

	return displayText;
    }

    private String updateDateTimings(Calendar startTime, Calendar endTime) {
	String displayText = "";

	String startTimeString = dateFormatter.format(startTime.getTime()) + HTML_SPACING;
	String endTimeString = dateFormatter.format(endTime.getTime());
	
	displayText = String.format(HTML_TIME_DISPLAY, startTimeString, endTimeString);
	
	return displayText;	
    }
    
    // The following int constants were generated on a trial&error basis:
    private int calculateToggleBtnXPos() {
	if (timedTask.getPriority() == INT_PRIORITY_NONE && !timedTask.getIsThereReminder()) {
	    return 699 + LEADING_XPOS_OFFSET + TRAILING_SPACE_OFFSET;
	} else if (timedTask.getPriority() == INT_PRIORITY_NONE && timedTask.getIsThereReminder()) {
	    return 699 + LEADING_XPOS_OFFSET + TRAILING_SPACE_OFFSET - 25 - 10;
	}

	return priorityIcon.getLocation().x - 13 - 25; 
    }

    private String formatInfoTimings() {
	String displayTime;
	if (timedTask.getStartTime().after(Calendar.getInstance())) {
	    displayTime = DATE_FORMAT_STARTS + prettyTimeParser.format(timedTask.getStartTime());
	} else if (timedTask.getEndTime().after(Calendar.getInstance())) {
	    displayTime = DATE_FORMAT_ENDS + prettyTimeParser.format(timedTask.getEndTime());
	} else {
	    displayTime = DATE_FORMAT_ENDED + prettyTimeParser.format(timedTask.getEndTime());
	}
	return displayTime;
    }

    private void setPriorityIcon(int priorityRef, boolean isThereReminder) {
	
	// The following int constants were generated on a trial&error basis::
	withoutReminderXPosOffset = 45;

	if (!isFloatingTask && isThereReminder) {
	    withoutReminderXPosOffset = 10;
	}

	if (priorityRef == INT_PRIORITY_HIGH) {
	    setPriHigh(withoutReminderXPosOffset);
	} else if (priorityRef == INT_PRIORITY_MEDIUM) {
	    setPriMed(withoutReminderXPosOffset);
	} else if (priorityRef == INT_PRIORITY_LOW) {
	    setPriLow(withoutReminderXPosOffset);
	} else {
	    priorityIcon.setVisible(false);
	}

    }
    
    // The following int constants were generated on a trial&error basis:
    
    private void setPriLow(int withoutReminderOffset) {
	priorityIcon.setIcon(bufferedGraphics.getLowPri());
	priorityIcon.setSize(DIMENSIONS_PRIORITY_ICON);
	priorityIcon.setLocation(655 + LEADING_XPOS_OFFSET + TRAILING_SPACE_OFFSET + withoutReminderOffset,  YPOS_PRIORITY_ICON);
	priorityIcon.setVisible(true);
    }

    private void setPriMed(int withoutReminderOffset) {
	priorityIcon.setIcon(bufferedGraphics.getMedPri());
	priorityIcon.setSize(DIMENSIONS_PRIORITY_ICON);
	priorityIcon.setLocation(655 + LEADING_XPOS_OFFSET + TRAILING_SPACE_OFFSET + withoutReminderOffset,  YPOS_PRIORITY_ICON);
	priorityIcon.setVisible(true);
    }

    private void setPriHigh(int withoutReminderOffset) {
	priorityIcon.setIcon(bufferedGraphics.getHighPri());
	priorityIcon.setSize(DIMENSIONS_PRIORITY_ICON);
	priorityIcon.setLocation(655 + LEADING_XPOS_OFFSET + TRAILING_SPACE_OFFSET + withoutReminderOffset, YPOS_PRIORITY_ICON);
	priorityIcon.setVisible(true);
    }

    private void setReminderIcon (boolean show) {
	if (show) {
	    reminderIcon.setVisible(true);
	} else {
	    reminderIcon.setVisible(false);
	}
    }

    private void setTimedDisplayText(String description, String location, String infoDisplayTime) {
	
	String displayText = String.format(HTML_INFO_DISPLAY, description, infoDisplayTime, location);
	text.setText(displayText);

	placeEllipsis(description, location, infoDisplayTime);
    }

    private void placeEllipsis(String description, String location,
	    String displayTime) {
	Dimension dimensions = text.getPreferredSize();
	if (dimensions.getWidth() > MAX_DISPLAY_TEXT_LENGTH) {
	    text.setSize(MAX_DISPLAY_TEXT_LENGTH, HEIGHT_ELLIPSIS);

	    ellipsis.setVisible(true);
	    text.setToolTipText(description + DESCRIPTION_SEPERATION_HYPHEN + displayTime + location);
	} else {
	    ellipsis.setVisible(false);
	    text.setToolTipText("");
	}
    }


    private void setCheckMark(boolean check) {

	if (check) {
	    uncheckedMark.setVisible(false);
	    checkMark.setVisible(true);


	} else {
	    uncheckedMark.setVisible(true);
	    checkMark.setVisible(false);

	}

    }

    private void showDateInfoIcon() {
	if (inDateDisplayState) {
	    infoIcon.setVisible(true);
	    dateIcon.setVisible(false);
	} else {
	    dateIcon.setVisible(true);
	    infoIcon.setVisible(false);
	}
    }

    private void hideDateInfoIcon() {
	dateIcon.setVisible(false);
	infoIcon.setVisible(false);
    }

    private void executeUncheck(final int guiId) {
	setCheckMark(false);
	TaskItem.controller.executeCommands(TaskItem.interpreter.getDefaultCommandSyn(CommandType.UNMARK) + INPUT_DELIMITER + TaskItem.interpreter.getDefaultParaSyn(ParameterType.TASK_ID) + SINGLE_SPACE + guiId);
	MainInterface.getSystemStatusMessage().setText(TaskItem.controller.getSystemMessageString());
	removeStrikeThrough();
    }

    private void executeCheck(final int guiId) {
	setCheckMark(true);
	TaskItem.controller.executeCommands(TaskItem.interpreter.getDefaultCommandSyn(CommandType.MARK) + INPUT_DELIMITER + TaskItem.interpreter.getDefaultParaSyn(ParameterType.TASK_ID) + SINGLE_SPACE + guiId);
	MainInterface.getSystemStatusMessage().setText(TaskItem.controller.getSystemMessageString());
	addStrikeThrough();
    }

}


	// End of segment: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\gui\TaskItem.java





	/**
	 * origin: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\gui\UserInputTextPane.java
	 */

class UserInputTextPane extends JTextPane {

    private static final long serialVersionUID = 1L;

    public UserInputTextPane() {
	super();
    }

    public UserInputTextPane(StyledDocument doc) {
	super(doc);
    }

    @Override
    public void replaceSelection(String content) {
	removeTextAttributes();
	super.replaceSelection(content);
	setFocus();
    }

    private void setFocus() {
	this.requestFocus();
    }

    private void removeTextAttributes() {
	getInputAttributes().removeAttribute(StyleConstants.Foreground);
	getInputAttributes().removeAttribute(StyleConstants.Bold);
	getInputAttributes().removeAttribute(StyleConstants.FontFamily);
    }
    
    public void appendParameter(String str, SimpleAttributeSet parameterSetting) throws BadLocationException
    {
	StyledDocument document = (StyledDocument) this.getDocument();
	document.insertString(document.getLength(), str, parameterSetting);
    }
}
	// End of segment: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\gui\UserInputTextPane.java





	/**
	 * origin: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\interpreter\Command.java
	 */


public class Command {
    private CommandType command;
    private Parameters parameters;

    public Command() {
        command = null;
        parameters = new Parameters();
    }
    
    
    public Command(CommandType command) {
        this.command = command;
        parameters = null;
    }
    
    public Command(CommandType command, Parameters parameters) {
        this.command = command;
        parameters = this.parameters;
    }
    

    
    public void setCommandType(CommandType command) {
        this.command = command;
    }
    
    public CommandFeedback setDescription(String description) {
        return parameters.setDescription(description);
    }
    
    public void setLocation(String location) {
        parameters.setLocation(location);
    }
    
    public CommandFeedback setFolder(String folder) {
        return parameters.setFolder(folder);
    }
    
    public CommandFeedback setPriority(String priority){
        return parameters.setPriority(priority);
    }
    
    public CommandFeedback setTaskId(String id) {
        return parameters.setTaskId(Integer.parseInt(id));
    }
    
    public CommandFeedback setStartTime(String time) {
        return parameters.setStartTime(time);
    }
    
    public CommandFeedback setEndTime(String time) {
        return parameters.setEndTime(time);
    }
    
    public CommandFeedback setRemindTime(String time) {
        return parameters.setRemindTime(time);
    }
    
    

    public CommandType getCommandType() {
        return command;
    }
    
    public Parameters getParameters() {
        return parameters;
    }
    
}

	// End of segment: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\interpreter\Command.java





	/**
	 * origin: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\interpreter\CommandFeedback.java
	 */

public enum CommandFeedback {
    
    INVALID_START_TIME, INVALID_END_TIME, INVALID_REMIND_TIME, 
    INVALID_PRIORITY, INVALID_FOLDER_REF, INVALID_TASK_ID,
    
    EMPTY_DESCRIPTION, EMPTY_LOCATION,
    
    INVALID_DATABASE_DUPLICATES, EMPTY_KEYWORD, MULTIPLE_WORD_KEYWORD,
    
    SUCCESSFUL_OPERATION;
}


	// End of segment: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\interpreter\CommandFeedback.java





	/**
	 * origin: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\interpreter\CommandType.java
	 */

public enum CommandType {
    
    ADD, MODIFY,
    DISPLAY_NOW, DISPLAY_TODAY, DISPLAY_TOMORROW, DISPLAY_WEEK, DISPLAY_MONTH, DISPLAY_ALL, DISPLAY_IN_TIME, DISPLAY_ALL_FLOAT,
    
    DELETE, DELETE_ALL_COMPLETED,  
    SEARCH, MARK, UNMARK, 
    
    QUIT, CLEAR, UNDO, REDO,
    
    EXPORT, IMPORT,
    
    INVALID
    
}

	// End of segment: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\interpreter\CommandType.java





	/**
	 * origin: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\interpreter\Config.java
	 */

public class Config
{
    private static final String BOOLEAN_REF_IS_COLLATED = "isDefaultCollated";

    private static final String BOOLEAN_REF_IS_FEEDBACK_ENABLED = "isActiveFeedbackEnabled";

    public final static Logger logger = Controller.getLogger();
    
    private static final String DELIMITER_PARAMETER = ",";
    private static final String FILENAME_USER_CONFIG_FILE = "Config.cfg";
    private static final String MESSAGE_GENERATING_CONFIG_FILE = "Config.cfg file not found. Generating Default Configurations";
    private static final String FILENAME_DEFAULT_CONFIG_FILE = "Default_Config.cfg";
    
    private static final String MESSAGE_SERIOUS_ERROR_DEFAULT_CONFIG_NOT_FOUND = "Serious error: Default config file not found";
    private static final String MESSAGE_DEFAULT_CONFIG_SAVE_FAILED = "Could save default config file. Settings can't be edited";
    
    private static final int INT_FOLDER5 = 5;
    private static final int INT_FOLDER4 = 4;
    private static final int INT_FOLDER3 = 3;
    private static final int INT_FOLDER2 = 2;
    private static final int INT_FOLDER1 = 1;
    private static final int INT_DEFAULT = 0;
    
    private static final String DEFAULT_ID_STRING = "default";
    private static final String FOLDER5_ID_STRING = "folder5";
    private static final String FOLDER4_ID_STRING = "folder4";
    private static final String FOLDER3_ID_STRING = "folder3";
    private static final String FOLDER2_ID_STRING = "folder2";
    private static final String FOLDER1_ID_STRING = "folder1";
    
    Properties configFile;
    
    private static Map<String, FolderName> folderNameRef = new HashMap<String, FolderName>();
    private static Map<FolderName, String> folderIdRef = new HashMap<FolderName, String>();
    private static Map<String, FolderName> folderIdHeader = new HashMap<String, FolderName>();
    private static Map<Integer, FolderName> intToFolderId = new HashMap<Integer, FolderName>();
    
    private static FolderName defaultFolder = FolderName.FOLDER1;   
    
    public Config()
    {
	clearAllMaps();
	loadConfigFile();

	buildFolderNameRef();
	buildFolderIdHeader();
	buildFolderIdRef();
	buildIntToFolderId();
    }

    public void buildIntToFolderId() {
	// To be used to decode logic's 'int' method of specifying folders:
	
	intToFolderId.put(INT_DEFAULT, FolderName.DEFAULT);
	intToFolderId.put(INT_FOLDER1, FolderName.FOLDER1);
	intToFolderId.put(INT_FOLDER2, FolderName.FOLDER2);
	intToFolderId.put(INT_FOLDER3, FolderName.FOLDER3);
	intToFolderId.put(INT_FOLDER4, FolderName.FOLDER4);
	intToFolderId.put(INT_FOLDER5, FolderName.FOLDER5);

	defaultFolder = folderIdHeader.get(folderIdRef.get(FolderName.DEFAULT));
    }

    public void buildFolderIdRef() {
	folderIdRef.put(FolderName.FOLDER1, getProperty(FOLDER1_ID_STRING).trim());
	folderIdRef.put(FolderName.FOLDER2, getProperty(FOLDER2_ID_STRING).trim());
	folderIdRef.put(FolderName.FOLDER3, getProperty(FOLDER3_ID_STRING).trim());
	folderIdRef.put(FolderName.FOLDER4, getProperty(FOLDER4_ID_STRING).trim());
	folderIdRef.put(FolderName.FOLDER5, getProperty(FOLDER5_ID_STRING).trim());
	folderIdRef.put(FolderName.DEFAULT, getProperty(DEFAULT_ID_STRING).trim());
    }

    public void buildFolderIdHeader() {
	folderIdHeader.put(FOLDER1_ID_STRING, FolderName.FOLDER1);
	folderIdHeader.put(FOLDER2_ID_STRING, FolderName.FOLDER2);
	folderIdHeader.put(FOLDER3_ID_STRING, FolderName.FOLDER3);
	folderIdHeader.put(FOLDER4_ID_STRING, FolderName.FOLDER4);
	folderIdHeader.put(FOLDER5_ID_STRING, FolderName.FOLDER5);
	folderIdHeader.put(DEFAULT_ID_STRING, FolderName.DEFAULT);
    }

    private void clearAllMaps() {
	folderNameRef.clear();
	folderIdRef.clear();
	folderIdHeader.clear();
	intToFolderId.clear();
    }

    public void buildFolderNameRef() {
	folderNameRef.put(getProperty(FOLDER1_ID_STRING).trim().toLowerCase(), FolderName.FOLDER1);
	folderNameRef.put(getProperty(FOLDER2_ID_STRING).trim().toLowerCase(), FolderName.FOLDER2);
	folderNameRef.put(getProperty(FOLDER3_ID_STRING).trim().toLowerCase(), FolderName.FOLDER3);
	folderNameRef.put(getProperty(FOLDER4_ID_STRING).trim().toLowerCase(), FolderName.FOLDER4);
	folderNameRef.put(getProperty(FOLDER5_ID_STRING).trim().toLowerCase(), FolderName.FOLDER5);
	folderNameRef.put(DEFAULT_ID_STRING, FolderName.DEFAULT);
    }

    public void loadConfigFile() {
	configFile = new java.util.Properties();
	try {
	    configFile.load(new FileInputStream(FILENAME_USER_CONFIG_FILE));

	}catch(Exception eta){
	    logger.log(Level.WARNING, MESSAGE_GENERATING_CONFIG_FILE);
	    loadDefaultConfig();
	}
    }

    public void loadDefaultConfig() {
	try {
	    configFile.load(Config.class.getResourceAsStream(FILENAME_DEFAULT_CONFIG_FILE));
	}catch(Exception severeException){
	    logger.log(Level.SEVERE, MESSAGE_SERIOUS_ERROR_DEFAULT_CONFIG_NOT_FOUND + severeException.getStackTrace());
	    Assert.fail(MESSAGE_SERIOUS_ERROR_DEFAULT_CONFIG_NOT_FOUND);
	}

	saveDefaultConfig();
    }

    public void saveDefaultConfig() {
	try {
	    configFile.store(new FileOutputStream(FILENAME_USER_CONFIG_FILE), null);
	} catch (FileNotFoundException serverException) {
	    logger.log(Level.SEVERE, MESSAGE_DEFAULT_CONFIG_SAVE_FAILED + serverException.getStackTrace());
	    Assert.fail(MESSAGE_DEFAULT_CONFIG_SAVE_FAILED);
	} catch (IOException serverException) {
	    logger.log(Level.SEVERE, MESSAGE_DEFAULT_CONFIG_SAVE_FAILED + serverException.getStackTrace());
	    Assert.fail(MESSAGE_DEFAULT_CONFIG_SAVE_FAILED);
	}
    }

    public String getProperty(String key)
    {
	return this.configFile.getProperty(key);
    }

    public String[] getSynonyms(String commandType) {
	return getProperty(commandType).trim().toLowerCase().split(DELIMITER_PARAMETER); 
    }

    public FolderName getFolderId(String folderName) {
	return folderNameRef.get(folderName);
    }

    public String getFolderName(FolderName folderId) {
	return folderIdRef.get(folderId);
    }

    public FolderName getDefaultFolder() {
	return defaultFolder;
    }

    public FolderName getFolderId (int folderInt) {
	assert (folderInt >= INT_DEFAULT && folderInt <= INT_FOLDER5);
	return intToFolderId.get(folderInt);
    }

    public Properties getConfigFile() {
	return configFile;
    }
    
    public boolean getIsActiveFeedbackEnabled() {
	return Boolean.parseBoolean(getProperty(BOOLEAN_REF_IS_FEEDBACK_ENABLED));
    }

    public boolean getIsDefaultCollated() {
	return Boolean.parseBoolean(getProperty(BOOLEAN_REF_IS_COLLATED));
    }
}
	// End of segment: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\interpreter\Config.java





	/**
	 * origin: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\interpreter\FolderName.java
	 */

public enum FolderName {
    FOLDER1, FOLDER2, FOLDER3, FOLDER4, FOLDER5, DEFAULT
}

	// End of segment: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\interpreter\FolderName.java





	/**
	 * origin: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\interpreter\Interpreter.java
	 */


public class Interpreter {
    
    private static final String EXCEPTION_ADDING_REMINDER_TO_FLOATING_TASK = "This is a non-timed task. If you want to add a reminder, please also specify start/end time";
    // Config keys:
    private static final String KEY_QUIT = "quit";
    private static final String KEY_IMPORT = "import";
    private static final String KEY_EXPORT = "export";
    private static final String KEY_DISPLAY_IN_TIME = "display";
    private static final String KEY_DISPLAY_FLOAT = "displayFloat";
    private static final String KEY_DISPLAY_ALL = "displayAll";
    private static final String KEY_REDO = "redo";
    private static final String KEY_UNDO = "undo";
    private static final String KEY_MONTH = "month";
    private static final String KEY_WEEK = "week";
    private static final String KEY_TOMORROW = "tomorrow";
    private static final String KEY_TODAY = "today";
    private static final String KEY_NOW = "now";
    private static final String KEY_SEARACH = "search";
    private static final String KEY_UNMARK = "unmark";
    private static final String KEY_MARK = "mark";
    private static final String KEY_MODIFY = "modify";
    private static final String KEY_CLEAR = "clear";
    private static final String KEY_CLEAR_COMPLETED = "clearCompleted";
    private static final String KEY_DELETE = "delete";
    private static final String KEY_ADD = "add";
    private static final String STRING_DEFAULT = "default";
    private static final String DELIMETER = "-";
    
    private static final String KEY_TASK_ID = "taskID";
    private static final String KEY_FOLDER = "folder";
    private static final String KEY_LOCATION = "location";
    private static final String KEY_PRIORITY = "priority";
    private static final String KEY_REMIND_TIME = "reminderTime";
    private static final String KEY_END_TIME = "endTime";
    private static final String KEY_START_TIME = "startTime";
    
    // Exception Messages:
    private static final String INVALID_COMMAND_TYPE = "Make sure that the first word is a valid command";
    private static final String EXCEPTION_EMPTY_ARGUMENT = "\"-%1$s\" is empty, please provide more info";
    private static final String EXCEPTION_DUPLICATE_PARAMETERS = "You have specified \"-%1$s\" more than once; it's confusing";
    private static final String INVALID_START_TIME = "Is the Start Time correct? Eg: tues, 19 May 2015 13:45, 05/19/2015, tonight, 10 min from now etc.";
    private static final String INVALID_END_TIME = "Is the End Time correct? Eg: tues, 19 May 2015 13:45, 05/19/2015, tonight, 10 min from now etc.";
    private static final String INVALID_REMINDER_TIME = "Is the Remind Time correct? Eg: tues, 19 May 2015 13:45, 05/19/2015, tonight, 10 min from now etc.";
    private static final String INVALID_PRIORITY_REF = "Is the priority high OR med OR low OR none (default)?";
    private static final String INVALID_FOLDER_REF = "Make sure that the name of the folder actually exists above";
    private static final String INVALID_TASK_ID = "Can't find Task Number '%1$s', check that it actually exists";
    private static final String INVALID_PARAMETER_TYPE = "What is \"-%1$s\"? Please correct the parameter name";
    private static final String INVALID_COMMAND_ARGUMENT = "You must added a description after \"%1$s\"";
    private static final String ERROR_DATABASE_DUPLICATE_PARA = "Duplicate keywords were found in the 'parameter' database for \"%1$s\"";
    private static final String ERROR_DATABASE_DUPLICATE_COMMAND = "Duplicate keywords were found in the 'command' database for \"%1$s\"";
    private static final String EXCEPTION_EMPTY_LOCATION = "Initiated location parameter cannot have a empty argument";
    private static final String EXCEPTION_EMPTY_DESCRIPTION = "Description cannot be empty";
    private static final String EXCEPTION_EMPTY_KEYWORD_IN_DATABASE = "The database contains empty synonym(s) in \"%1$s\"";
    private static final String EXCEPTION_KEYWORD_MULTIPLE_WORDS = "The synonym(s) for \"%1$s\" have to be single words";
    private static final String EXCEPTION_END_TIME_BEFORE_START_TIME = "Please check that 'start time' occurs chronologically before 'end time'";
    private static final String EXCEPTION_ID_NOT_SPECIFIED = "Please specify the Task Number of the task";
    
    /* DEPRECIATED:
    private static final String EXCEPTION_NO_END_TIME_SPECIFIED = "You must specify 'end time' since you have specified 'start time' OR just specify 'end time'";
    */
    
    // Logging Info:
    private static final String INFO_READ_KEYWORD_DATABASE = "Command and Keyword database intiated properly";
    private static final String INFO_LOADED_KEYWORD_HEADERS = "Command and Keyword headers loaded";
    private static final String INFO_SETTING_PANE_CHECK_NEW_DATABASE = "GUI Settings Pane using interpreter";
    private static final String INFO_SETTINGS_PANE_SAVING_CONFIG = "GUI Settings Pane saving Config file";
    
    // Other exceptions:
    private static final int EXCEPTION_NON_EXISTENT_ID = -1;
    private static int floatingTaskGuiRef;
    public final static Logger logger = Controller.getLogger();
    
    // Hash maps:
    private static Map<String, CommandType> commandKeywords = new HashMap<String, CommandType>();
    private static Map<String, ParameterType> parameterKeywords = new HashMap<String, ParameterType>();
    
    private static Map<CommandType, String> defaultCommandSynonym = new HashMap<CommandType, String>();
    private static Map<ParameterType, String> defaultParameterSynonym = new HashMap<ParameterType, String>();
    
    private static Map<Integer, Integer> guiIdRef = new HashMap<Integer, Integer>();
    private static Config cfg = new Config();
    
    private ArrayList<ParameterType> currentParameters = new ArrayList<ParameterType>(); // For duplicates
    private Command command = new Command();
    
    private String currentFolder = STRING_DEFAULT;
    private static final int FIRST_ARGUMENT = 0;
    
    private static boolean isGuiIdEnabled = false;
    
    /* Keyword Headers: Mapping Config file elements to Command & Parameter types */
    
    private static final Map<String, CommandType> commandHeaders;
    private static final Map<String, ParameterType> parameterHeaders;
    static
    {
        // Main Commands:  
        
        commandHeaders = new HashMap<String, CommandType>();
        
        commandHeaders.put(KEY_ADD, CommandType.ADD);
        commandHeaders.put(KEY_DELETE, CommandType.DELETE);
        commandHeaders.put(KEY_CLEAR_COMPLETED, CommandType.DELETE_ALL_COMPLETED);
        commandHeaders.put(KEY_CLEAR, CommandType.CLEAR);
        commandHeaders.put(KEY_MODIFY, CommandType.MODIFY);
        commandHeaders.put(KEY_MARK, CommandType.MARK);
        commandHeaders.put(KEY_UNMARK, CommandType.UNMARK);
        commandHeaders.put(KEY_SEARACH, CommandType.SEARCH);
        commandHeaders.put(KEY_NOW, CommandType.DISPLAY_NOW);
        commandHeaders.put(KEY_TODAY, CommandType.DISPLAY_TODAY);
        commandHeaders.put(KEY_TOMORROW, CommandType.DISPLAY_TOMORROW);
        commandHeaders.put(KEY_WEEK, CommandType.DISPLAY_WEEK);
        commandHeaders.put(KEY_MONTH, CommandType.DISPLAY_MONTH);
        commandHeaders.put(KEY_UNDO, CommandType.UNDO);
        commandHeaders.put(KEY_REDO, CommandType.REDO);
        commandHeaders.put(KEY_DISPLAY_ALL, CommandType.DISPLAY_ALL);
        commandHeaders.put(KEY_DISPLAY_FLOAT, CommandType.DISPLAY_ALL_FLOAT);
        commandHeaders.put(KEY_DISPLAY_IN_TIME, CommandType.DISPLAY_IN_TIME);
        commandHeaders.put(KEY_EXPORT, CommandType.EXPORT);
        commandHeaders.put(KEY_IMPORT, CommandType.IMPORT);
        commandHeaders.put(KEY_QUIT, CommandType.QUIT);
        
        // Parameter Commands:
        
        parameterHeaders = new HashMap<String, ParameterType>();
        
        parameterHeaders.put(KEY_START_TIME, ParameterType.START_TIME);
        parameterHeaders.put(KEY_END_TIME, ParameterType.END_TIME);
        parameterHeaders.put(KEY_REMIND_TIME, ParameterType.REMINDER_TIME);
        parameterHeaders.put(KEY_PRIORITY,ParameterType.PRIORITY);
        parameterHeaders.put(KEY_LOCATION, ParameterType.LOCATION);
        parameterHeaders.put(KEY_FOLDER, ParameterType.FOLDER);
        parameterHeaders.put(KEY_TASK_ID, ParameterType.TASK_ID);
        
        logger.log(Level.FINE, INFO_LOADED_KEYWORD_HEADERS);
        
	readCommandDatabase();
	readParameterDatabase();
	
	logger.log(Level.FINE, INFO_READ_KEYWORD_DATABASE);
    }
    
    public Interpreter() {
	// Do nothing
    }
  
    
    /*
     * To be used by settings pane for checking validity of keywords:
     */
   
    public Interpreter(Properties props) {
	
	logger.log(Level.FINEST, INFO_SETTING_PANE_CHECK_NEW_DATABASE);
	
	commandKeywords.clear();
	parameterKeywords.clear();
	
	readCommandDatabase(props);
	readParameterDatabase(props);
    }
    
    /*
     * Used when Config file has to be re-read:
     */
    
    public Interpreter(boolean rebuild) {
	
	logger.log(Level.FINEST, INFO_SETTINGS_PANE_SAVING_CONFIG);
	
	if (rebuild) {
	    cfg = new Config();
	    
	    commandKeywords.clear();
	    parameterKeywords.clear();
	    
	    readCommandDatabase();
	    readParameterDatabase();
	}
    }
    
    
    /**
     * Reads keywords from txtfile and saves them in the local memory (hash table)
     * 
     */
    
    private static void readCommandDatabase() throws IllegalArgumentException {
        
	defaultCommandSynonym.clear();
	
        String[] headerKeySet = (String[])( commandHeaders.keySet().toArray( new String[commandHeaders.size()] ) );
        
        for (int i = 0; i < commandHeaders.size(); i++) {

            CommandFeedback feedback = addCommandSynonyms(cfg, headerKeySet[i], commandHeaders.get(headerKeySet[i]));

            checkCommandDatabaseExceptions(headerKeySet, i, feedback);
        }
    }
    
    
    /*
     * Function to be used by settings pane:
     */
    
    private static void readCommandDatabase(Properties props) throws IllegalArgumentException {
        
	defaultCommandSynonym.clear();
	
	String[] headerKeySet = (String[])( commandHeaders.keySet().toArray( new String[commandHeaders.size()] ) );
        
        for (int i = 0; i < commandHeaders.size(); i++) {

            CommandFeedback feedback = addCommandSynonyms(props, headerKeySet[i], commandHeaders.get(headerKeySet[i]));

            checkCommandDatabaseExceptions(headerKeySet, i, feedback);
        }
    }

    public static void checkCommandDatabaseExceptions(String[] headerKeySet, int i,
	    CommandFeedback feedback) {
	if (feedback == CommandFeedback.INVALID_DATABASE_DUPLICATES) {
	    logger.log(Level.WARNING, String.format(ERROR_DATABASE_DUPLICATE_COMMAND, headerKeySet[i].toString()));
	    throw new IllegalArgumentException(String.format(ERROR_DATABASE_DUPLICATE_COMMAND, headerKeySet[i].toString()));
	}

	if (feedback == CommandFeedback.EMPTY_KEYWORD) {
	    logger.log(Level.WARNING, String.format(EXCEPTION_EMPTY_KEYWORD_IN_DATABASE, headerKeySet[i].toString()));
	    throw new IllegalArgumentException(String.format(EXCEPTION_EMPTY_KEYWORD_IN_DATABASE, headerKeySet[i].toString()));
	}

	if (feedback == CommandFeedback.MULTIPLE_WORD_KEYWORD) {
	    logger.log(Level.WARNING, String.format(EXCEPTION_KEYWORD_MULTIPLE_WORDS, headerKeySet[i].toString()));
	    throw new IllegalArgumentException(String.format(EXCEPTION_KEYWORD_MULTIPLE_WORDS, headerKeySet[i].toString()));
	}
    }

    private static CommandFeedback addCommandSynonyms(Config cfg, String type, CommandType commandType) 
    {
        String[] keys = cfg.getSynonyms(type);
        
        for (int i=0; i<keys.length; i++) {
            String key = keys[i].trim();
            
            if (hasMultipleWords(key)) {
        	return CommandFeedback.MULTIPLE_WORD_KEYWORD;
            } else if (key.isEmpty()) {
        	return CommandFeedback.EMPTY_KEYWORD;
            } else if (!commandKeywords.containsKey(key)) {
                commandKeywords.put(key, commandType);
            } else {
                return CommandFeedback.INVALID_DATABASE_DUPLICATES;
            }
        }
        
        defaultCommandSynonym.put(commandType, keys[0]);
        
        return CommandFeedback.SUCCESSFUL_OPERATION;
    }
    
    /*
     * Function to be used by settings pane:
     */
    
    private static CommandFeedback addCommandSynonyms(Properties props, String type, CommandType commandType) 
    {
        String[] keys = parseProperties(props, type);
        
        for (int i=0; i<keys.length; i++) {
            String key = keys[i].trim();
            
            if (hasMultipleWords(key)) {
        	return CommandFeedback.MULTIPLE_WORD_KEYWORD;
            } else if (key.isEmpty()) {
        	return CommandFeedback.EMPTY_KEYWORD;
            } else if (!commandKeywords.containsKey(key)) {
                commandKeywords.put(key, commandType);
            } else {
                return CommandFeedback.INVALID_DATABASE_DUPLICATES;
            }
        }
        
        defaultCommandSynonym.put(commandType, keys[0]);
        
        return CommandFeedback.SUCCESSFUL_OPERATION;
    }
    
    
    
    private static void readParameterDatabase() throws IllegalArgumentException {
	
	defaultParameterSynonym.clear();
        
        String[] headerKeySet = (String[])( parameterHeaders.keySet().toArray( new String[parameterHeaders.size()] ) );
        
        for (int i = 0; i < parameterHeaders.size(); i++) {

            CommandFeedback feedback = addParameterSynonyms(cfg, headerKeySet[i], parameterHeaders.get(headerKeySet[i]));

            checkParameterDatabaseExceptions(headerKeySet, i, feedback);
        }
    }
    
    /*
     * Function to be used by settings pane:
     */
    
    private static void readParameterDatabase(Properties props) throws IllegalArgumentException {
	
	defaultParameterSynonym.clear();
        
        String[] headerKeySet = (String[])( parameterHeaders.keySet().toArray( new String[parameterHeaders.size()] ) );
        
        for (int i = 0; i < parameterHeaders.size(); i++) {

            CommandFeedback feedback = addParameterSynonyms(props, headerKeySet[i], parameterHeaders.get(headerKeySet[i]));

            checkParameterDatabaseExceptions(headerKeySet, i, feedback);
        }
    }


    public static void checkParameterDatabaseExceptions(String[] headerKeySet,
	    int i, CommandFeedback feedback) {
	if (feedback == CommandFeedback.INVALID_DATABASE_DUPLICATES) {
	    logger.log(Level.WARNING, String.format(ERROR_DATABASE_DUPLICATE_PARA, headerKeySet[i].toString()));
	    throw new IllegalArgumentException(String.format(ERROR_DATABASE_DUPLICATE_PARA, headerKeySet[i].toString()));
	}

	if (feedback == CommandFeedback.EMPTY_KEYWORD) {
	    logger.log(Level.WARNING, String.format(EXCEPTION_EMPTY_KEYWORD_IN_DATABASE, headerKeySet[i].toString()));
	    throw new IllegalArgumentException(String.format(EXCEPTION_EMPTY_KEYWORD_IN_DATABASE, headerKeySet[i].toString()));
	}

	if (feedback == CommandFeedback.MULTIPLE_WORD_KEYWORD) {
	    logger.log(Level.WARNING, String.format(EXCEPTION_KEYWORD_MULTIPLE_WORDS, headerKeySet[i].toString()));
	    throw new IllegalArgumentException(String.format(EXCEPTION_KEYWORD_MULTIPLE_WORDS, headerKeySet[i].toString()));
	}
    }


    private static CommandFeedback addParameterSynonyms(Config cfg, String type, ParameterType parameterType) 
    {
	String[] keys = cfg.getSynonyms(type);

	for (int i=0; i<keys.length; i++) {
	    String key = keys[i].trim();

	    if (hasMultipleWords(key)) {
		return CommandFeedback.MULTIPLE_WORD_KEYWORD;
	    } else if (key.isEmpty()) {
		return CommandFeedback.EMPTY_KEYWORD;
            } else if (!parameterKeywords.containsKey(key)) {
                parameterKeywords.put(key, parameterType);
            } else {
                return CommandFeedback.INVALID_DATABASE_DUPLICATES;
            }
        }
        
        defaultParameterSynonym.put(parameterType, keys[0]);
        
        return CommandFeedback.SUCCESSFUL_OPERATION;
    }
    
    /*
     * Function to be used by settings pane:
     */
    
    private static CommandFeedback addParameterSynonyms(Properties props, String type, ParameterType parameterType) 
    {
	String[] keys = parseProperties(props, type);
        
        for (int i=0; i<keys.length; i++) {
            String key = keys[i].trim();
            
            if (hasMultipleWords(key)) {
        	return CommandFeedback.MULTIPLE_WORD_KEYWORD;
            } else if (key.isEmpty()) {
        	return CommandFeedback.EMPTY_KEYWORD;
            } else if (!parameterKeywords.containsKey(key)) {
                parameterKeywords.put(key, parameterType);
            } else {
                return CommandFeedback.INVALID_DATABASE_DUPLICATES;
            }
        }
        
        defaultParameterSynonym.put(parameterType, keys[0]);
        
        return CommandFeedback.SUCCESSFUL_OPERATION;
    }


    public static String[] parseProperties(Properties props, String type) {
	return ((String) props.get((String) type)).trim().toLowerCase().split(",");
    }
    
    private static boolean hasMultipleWords(String input) {
	return input.indexOf(' ') >= 0;
    }
    
    public void processUserInput(String input) {
        CommandType mainCommand = extractMainCommand(input);
        
        checkCommandValidity(mainCommand);
        processCommandArgument(input);
        
        if (hasParameters(mainCommand)) {
            parseAndProcessParameters(input);
        }
        
        command.setCommandType(mainCommand); 
        checkForOtherExceptions();
        
        updateCurrFolderReference();
    }


    public CommandType extractMainCommand(String input) {
	String commandString = getFirstWord(input);
        CommandType mainCommand = interpretCommand(commandString);
	return mainCommand;
    }
    
    private void checkForOtherExceptions() throws IllegalArgumentException {
	
	/* DEPRECIATED: Logic adds default end time
	if (!currentParameters.contains(ParameterType.END_TIME) && currentParameters.contains(ParameterType.START_TIME)) {
	    logger.log(Level.WARNING, EXCEPTION_NO_END_TIME_SPECIFIED);
	    throw new IllegalArgumentException(EXCEPTION_NO_END_TIME_SPECIFIED);
	}
	*/
	
	if (isStartEndNotChronological()) {
	    logger.log(Level.WARNING, EXCEPTION_END_TIME_BEFORE_START_TIME);
	    throw new IllegalArgumentException(EXCEPTION_END_TIME_BEFORE_START_TIME);
	}
	
	
	if (hasNoTaskId()) {
	    logger.log(Level.WARNING, EXCEPTION_ID_NOT_SPECIFIED);
	    throw new IllegalArgumentException(EXCEPTION_ID_NOT_SPECIFIED);
	}
	
	if (addingReminderToFloatingTask()) {
	    
	    logger.log(Level.WARNING, EXCEPTION_ADDING_REMINDER_TO_FLOATING_TASK);
	    throw new IllegalArgumentException(EXCEPTION_ADDING_REMINDER_TO_FLOATING_TASK);
	}
	
    }


    private boolean addingReminderToFloatingTask() {	
	return command.getCommandType() == CommandType.MODIFY && isGuiIdEnabled && isFloatingTask(command.getParameters().getGuiIdRef()) && currentParameters.contains(ParameterType.REMINDER_TIME) && !(currentParameters.contains(ParameterType.START_TIME) || currentParameters.contains(ParameterType.END_TIME));
    }


    private boolean hasNoTaskId() {
	return needsId(command.getCommandType()) && !currentParameters.contains(ParameterType.TASK_ID);
    }


    private boolean isStartEndNotChronological() {
	return (currentParameters.contains(ParameterType.END_TIME) && currentParameters.contains(ParameterType.START_TIME)) && command.getParameters().getStartTime().after(command.getParameters().getEndTime());
    }
    
    private void updateCurrFolderReference() {
	if (command.getParameters().getFolder() == null) {
	    command.getParameters().setFolder(currentFolder);
	}
    }
    
    public boolean isFloatingTask() {
	if (currentParameters.contains(ParameterType.START_TIME) || currentParameters.contains(ParameterType.END_TIME) || currentParameters.contains(ParameterType.REMINDER_TIME)) {
	    return false;
	}
	
	return true;
    }
    
    private void processCommandArgument (String input) throws IllegalArgumentException {
	
	String commandArgument = null;
	
	try {
		commandArgument = getDescription(input);
	} catch (ArrayIndexOutOfBoundsException aE) {
	    return;
	}
		
        CommandFeedback feedback = command.setDescription(commandArgument);
        
        if (needsDescription(interpretCommand(getFirstWord(input))) && feedback == CommandFeedback.EMPTY_DESCRIPTION) {
            logger.log(Level.WARNING, String.format(INVALID_COMMAND_ARGUMENT, getFirstWord(input)));
            throw new IllegalArgumentException(String.format(INVALID_COMMAND_ARGUMENT, getFirstWord(input)));
        }
                
    }


    private String getDescription(String input) {
	return (input.substring(getFirstWord(input).length()).trim()).split(DELIMETER)[FIRST_ARGUMENT].trim();
    }
    
    private boolean needsDescription(CommandType userCommand) {
        
        if (userCommand == CommandType.ADD || userCommand == CommandType.SEARCH || userCommand == CommandType.IMPORT || userCommand == CommandType.EXPORT) {
            return true;
        }
        
        return false;
    }
    
    private boolean needsId(CommandType userCommand) {
	
        if (userCommand == CommandType.MODIFY || userCommand == CommandType.MARK || userCommand == CommandType.UNMARK) {
            return true;
        }
        
	return false;
    }


    private void checkCommandValidity(CommandType mainCommand) throws InvalidParameterException {
        if (mainCommand == CommandType.INVALID) {
            logger.log(Level.WARNING, INVALID_COMMAND_TYPE);
            throw new InvalidParameterException(INVALID_COMMAND_TYPE);
        }
    }
    
    
    private void parseAndProcessParameters(String input) throws IllegalArgumentException {
        String[] inputParameters = input.split(DELIMETER);
        
        currentParameters.clear();
        
        for (int i=1; i<inputParameters.length; i++) { // Ignore the command, focus on the parameter arguments
            String paraTypeString = getFirstWord(inputParameters[i]);
            String paraArgument = isolateArgument(inputParameters, i, paraTypeString);
            
            
            ParameterType parameterType = interpretParameter(paraTypeString);
            checkForParameterExceptions(paraTypeString, paraArgument, parameterType);
            
            CommandFeedback feedback = processParameter(parameterType, paraArgument);
            isParameterArgumentValid(paraArgument, feedback);
            
            checkIfParameterExists(paraTypeString, parameterType); 
        }
        
    }


    public String isolateArgument(String[] inputParameters, int i,
	    String paraTypeString) {
	return inputParameters[i].substring(paraTypeString.length()).trim();
    }


    public void checkForParameterExceptions(String paraTypeString, String paraArgument,
	    ParameterType parameterType) {
	if (parameterType == ParameterType.INVALID) {
	    logger.log(Level.WARNING, String.format(INVALID_PARAMETER_TYPE, paraTypeString));
	    throw new IllegalArgumentException(String.format(INVALID_PARAMETER_TYPE, paraTypeString));
	}
	
	if (paraArgument.isEmpty()) {
	    logger.log(Level.WARNING, String.format(EXCEPTION_EMPTY_ARGUMENT, paraTypeString));
	    throw new IllegalArgumentException(String.format(EXCEPTION_EMPTY_ARGUMENT, paraTypeString));
	}
    }


    public void checkIfParameterExists(String paraTypeString, ParameterType parameterType) throws IllegalArgumentException {
	if (currentParameters.contains(parameterType)) {
	    logger.log(Level.WARNING, String.format(EXCEPTION_DUPLICATE_PARAMETERS, paraTypeString));
            throw new IllegalArgumentException(String.format(EXCEPTION_DUPLICATE_PARAMETERS, paraTypeString));
        }
	
        currentParameters.add(parameterType);
    }
    
    private void isParameterArgumentValid (String paraArgument, CommandFeedback feedback) throws InvalidParameterException {
        switch (feedback) {
        case EMPTY_DESCRIPTION:
            logger.log(Level.WARNING, EXCEPTION_EMPTY_DESCRIPTION);
            throw new InvalidParameterException(EXCEPTION_EMPTY_DESCRIPTION);   
        case EMPTY_LOCATION:
            logger.log(Level.WARNING, EXCEPTION_EMPTY_LOCATION);
            throw new InvalidParameterException(EXCEPTION_EMPTY_LOCATION);          
        case INVALID_START_TIME:
            logger.log(Level.WARNING, INVALID_START_TIME);
            throw new InvalidParameterException(INVALID_START_TIME);
        case INVALID_END_TIME:
            logger.log(Level.WARNING, INVALID_END_TIME);
            throw new InvalidParameterException(INVALID_END_TIME);
        case INVALID_REMIND_TIME:
            logger.log(Level.WARNING, INVALID_REMINDER_TIME);
            throw new InvalidParameterException(INVALID_REMINDER_TIME);
        case INVALID_PRIORITY:
            logger.log(Level.WARNING, INVALID_PRIORITY_REF);
            throw new InvalidParameterException(INVALID_PRIORITY_REF);
        case INVALID_FOLDER_REF:
            logger.log(Level.WARNING, INVALID_FOLDER_REF);
            throw new InvalidParameterException(INVALID_FOLDER_REF);
        case INVALID_TASK_ID:
            logger.log(Level.WARNING, String.format(INVALID_TASK_ID, paraArgument));
            throw new InvalidParameterException(String.format(INVALID_TASK_ID, paraArgument));           
        default:
            return;        
        }
        
    }
    
    public String getFirstWord(String input) {
        return input.trim().split("\\s+")[0].toLowerCase();
    }
 
    
    public boolean hasParameters(CommandType command) {
        if (command == CommandType.ADD || command == CommandType.DELETE || command == CommandType.MARK || command == CommandType.UNMARK || command == CommandType.MODIFY || command == CommandType.SEARCH || command == CommandType.DISPLAY_IN_TIME || command == CommandType.CLEAR || command == CommandType.DELETE_ALL_COMPLETED) {
            return true;
        }
            
        return false;
    }
    
    private CommandFeedback processParameter(ParameterType parameterType, String argument) throws InvalidParameterException
    {   
        switch(parameterType) {
        
        case START_TIME:
            return command.setStartTime(argument);
        case END_TIME:
            return command.setEndTime(argument);
        case REMINDER_TIME:
            return command.setRemindTime(argument);
        case PRIORITY:
            return command.setPriority(argument);
        case TASK_ID:
            return command.setTaskId(argument);
        case FOLDER:
            return command.setFolder(argument);
        case LOCATION:
            command.setLocation(argument);
            return CommandFeedback.SUCCESSFUL_OPERATION;            
            
        default:
            throw new InvalidParameterException(INVALID_PARAMETER_TYPE); 
        
        }
        
    }
    
    public String getDefaultCommandSyn(CommandType commandType) {
	return defaultCommandSynonym.get(commandType);
    }
    
    public String getDefaultParaSyn(ParameterType parameterType) {
	return defaultParameterSynonym.get(parameterType);
    }
    
    /*
     * For interfacing with GUI:
     */
    
    public static void setIsGuiIdEnabled(boolean isGuiIdEnabled) {
	Interpreter.isGuiIdEnabled = isGuiIdEnabled;
    }
    
    public static boolean checkIsGuiIdEnabled() {
	return isGuiIdEnabled;
    }

    public static void addGuiId(int guiId, int realTaskId){
	if (isGuiIdEnabled) {
	    guiIdRef.put(guiId, realTaskId);
	}

	return;
    }

    public static int getRealId(int guiId) {
	if (isGuiIdEnabled) {

	    if (guiIdRef.get(guiId) == null) {
		return EXCEPTION_NON_EXISTENT_ID;
	    }

	    return guiIdRef.get(guiId);
	}

	return EXCEPTION_NON_EXISTENT_ID;
    }

    public static void clearGuiIdMap() {
	guiIdRef.clear();
    }
    
    
    public static void setFloatingTaskGuiRef(int startGuiIndex) {
	
	if (isGuiIdEnabled) {
	    floatingTaskGuiRef = startGuiIndex;
	}
    }
    
    public static boolean isFloatingTask(int guiId) {
	if (isGuiIdEnabled && guiId >= floatingTaskGuiRef) {
	    return true;
	}
	
	return false;
    }
    
    public ParameterType interpretParameter(String parameterString) {
        if (!parameterKeywords.containsKey(parameterString)) {
            return ParameterType.INVALID;
        }
        
        return parameterKeywords.get(parameterString);
    }
    
    public CommandType interpretCommand(String commandString) {
        if (!commandKeywords.containsKey(commandString)) {
            return CommandType.INVALID;
        }
        
        return commandKeywords.get(commandString);
    }
      
    
    public Command getCommandAndPara() {
        return command;
    }
    
    public String getCurrentFolder() {
	return currentFolder;
    }
    
    public void setCurrentFolder(String currFolderName) {
	currentFolder = currFolderName;
    }
}
	// End of segment: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\interpreter\Interpreter.java





	/**
	 * origin: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\interpreter\InterpreterTest.java
	 */


/* 
 * InterpreterTest.java has 85.4% path coverage of the Interpreter package. 
 * The other 15% mainly deals with GUI interaction and Config IO. 
 * 
 */

public class InterpreterTest {
    
    // Exception Messages:
    private static final String INVALID_COMMAND_TYPE = "Invalid command type";
    private static final String EXCEPTION_EMPTY_ARGUMENT = "Cannot accept empty parameter argument";
    private static final String INVALID_START_TIME = "Invalid start time";
    private static final String INVALID_END_TIME = "Invalid end time";
    private static final String INVALID_REMINDER_TIME = "Invalid remind time";
    private static final String INVALID_PRIORITY_REF = "Invalid priority reference";
    private static final String INVALID_FOLDER_REF = "Invalid folder reference";
    private static final String INVALID_TASK_ID = "Invalid task id reference";
    private static final String INVALID_PARAMETER_TYPE = "Invalid parameter type";
    private static final String INVALID_COMMAND_ARGUMENT = "The description for this command cannot be empty";
    private static final String EXCEPTION_END_TIME_BEFORE_START_TIME = "Please check that 'start time' occurs chronologically before 'end time'";
    private static final String EXCEPTION_ID_NOT_SPECIFIED = "Please specify the ID of the task";
    
    // Initialize interpreter:
    Interpreter interpreter = new Interpreter();
    
    @Test 
    public void testDatabase() {
	
	synonymInterpretations();
	invalidInterpretaions();
	
	checkAllValidKeywords();
	
    }

    private void checkAllValidKeywords() {
	
	// NOTE: the following keyword strings will be invalid if the Config.cfg file is edited
	
	// Commands:
	assertEquals(CommandType.ADD, interpreter.interpretCommand("add"));
	assertEquals(CommandType.DELETE, interpreter.interpretCommand("remove"));
	assertEquals(CommandType.MODIFY, interpreter.interpretCommand("modify"));
	assertEquals(CommandType.UNMARK, interpreter.interpretCommand("unmark"));
	assertEquals(CommandType.DELETE_ALL_COMPLETED, interpreter.interpretCommand("cc"));
	assertEquals(CommandType.CLEAR, interpreter.interpretCommand("clear"));
	assertEquals(CommandType.SEARCH, interpreter.interpretCommand("search"));
	assertEquals(CommandType.DISPLAY_NOW, interpreter.interpretCommand("now"));
	assertEquals(CommandType.DISPLAY_TODAY, interpreter.interpretCommand("today"));
	assertEquals(CommandType.DISPLAY_TOMORROW, interpreter.interpretCommand("tomr"));
	assertEquals(CommandType.DISPLAY_ALL, interpreter.interpretCommand("all"));
	assertEquals(CommandType.DISPLAY_ALL_FLOAT, interpreter.interpretCommand("float"));
	assertEquals(CommandType.DISPLAY_IN_TIME, interpreter.interpretCommand("display"));
	assertEquals(CommandType.DISPLAY_WEEK, interpreter.interpretCommand("week"));
	assertEquals(CommandType.DISPLAY_MONTH, interpreter.interpretCommand("month"));
	assertEquals(CommandType.UNDO, interpreter.interpretCommand("undo"));
	assertEquals(CommandType.REDO, interpreter.interpretCommand("redo"));
	assertEquals(CommandType.EXPORT, interpreter.interpretCommand("export"));
	assertEquals(CommandType.QUIT, interpreter.interpretCommand("quit"));
	
	// Parameters:
	assertEquals(ParameterType.START_TIME, interpreter.interpretParameter("start"));
	assertEquals(ParameterType.END_TIME, interpreter.interpretParameter("end"));
	assertEquals(ParameterType.REMINDER_TIME, interpreter.interpretParameter("remind"));
	assertEquals(ParameterType.LOCATION, interpreter.interpretParameter("location"));
	assertEquals(ParameterType.FOLDER, interpreter.interpretParameter("folder"));
	assertEquals(ParameterType.TASK_ID, interpreter.interpretParameter("id"));
		
    }

    private void invalidInterpretaions() {
	
	// Invalid because string is expected to be trimmed/cleaned-up before using this function:
	assertEquals(CommandType.INVALID, interpreter.interpretCommand("  add  "));
	assertEquals(CommandType.INVALID, interpreter.interpretCommand("  a  "));
	assertEquals(ParameterType.INVALID, interpreter.interpretParameter(" start"));
	assertEquals(ParameterType.INVALID, interpreter.interpretParameter(" on   "));
	
	// Invalid because string is expected to be in lower-case before using this function:
	assertEquals(CommandType.INVALID, interpreter.interpretCommand("Add"));
	assertEquals(CommandType.INVALID, interpreter.interpretCommand("creAte"));
	assertEquals(ParameterType.INVALID, interpreter.interpretParameter("sTarT"));
	assertEquals(ParameterType.INVALID, interpreter.interpretParameter("oN"));
	
	// Invalid synonyms:
	assertEquals(CommandType.INVALID, interpreter.interpretCommand(" addition "));	
	assertEquals(CommandType.INVALID, interpreter.interpretCommand("addition"));	
	assertEquals(ParameterType.INVALID, interpreter.interpretParameter("startTime"));
    }

    private void synonymInterpretations() {
	
	assertEquals(CommandType.ADD, interpreter.interpretCommand("new"));
	assertEquals(CommandType.ADD, interpreter.interpretCommand("create"));
	assertEquals(CommandType.ADD, interpreter.interpretCommand("a"));
	assertEquals(CommandType.ADD, interpreter.interpretCommand("n"));
	
    }
    
    
    /*
     * The Interpreter class will be used across various parts of the application. So it needs to manage multiple 
     * instantiations, while maintaining a static keyword database
     */
    
    @Test
    public void testMultipleInstances() {
	
	Interpreter secondInterpreter = new Interpreter();
	
	interpreter.processUserInput("aDd new task from 1st instance -end 10 dec 2014 13:35:34 -pri none -loc location 1");
	secondInterpreter.processUserInput("seaRch second task from 2nd instance");
	
	checkFirstInstance(interpreter);
	checkSecondInstance(secondInterpreter);
	
    }
    
    private void checkFirstInstance(Interpreter instance) {
	
	assertEquals(CommandType.ADD, instance.getCommandAndPara().getCommandType());
	assertEquals("new task from 1st instance", instance.getCommandAndPara().getParameters().getDescription());
	assertEquals("0", instance.getCommandAndPara().getParameters().getPriority());
	assertEquals("location 1", instance.getCommandAndPara().getParameters().getLocation());
	
	// In UTC time:
	assertEquals("1418189734000", Long.toString(instance.getCommandAndPara().getParameters().getEndTime().getTimeInMillis()));
	
    }
    
    private void checkSecondInstance(Interpreter instance) {
	
	assertEquals(CommandType.SEARCH, instance.getCommandAndPara().getCommandType());
	assertEquals("second task from 2nd instance", instance.getCommandAndPara().getParameters().getDescription());
	
    }
    
    
    @Test
    public void testTokenization() {
	
	validTokenization();
	handleExceptions();
	checkDefaultKeywords();
		
    }

    private void validTokenization() {
	
	// Note: Commands and Parameters are case insensitive
	interpreter.processUserInput("mOdiFy new descriptiOn -iD 12 -staRt 10 july 2014 12:34:23 -eND 15 july 2014 12:34:23 -ReMiNd 12 july 2014 12:34:23 -Pri high -lOc new location -FOLDER default");
	
	// Check all 'Command & Parameter' properties:
	assertEquals(CommandType.MODIFY, interpreter.getCommandAndPara().getCommandType());
	assertEquals("new descriptiOn", interpreter.getCommandAndPara().getParameters().getDescription());
	assertEquals("12", interpreter.getCommandAndPara().getParameters().getTaskId());
	assertEquals("1404966863000", Long.toString(interpreter.getCommandAndPara().getParameters().getStartTime().getTimeInMillis()));
	assertEquals("1405398863000", Long.toString(interpreter.getCommandAndPara().getParameters().getEndTime().getTimeInMillis()));
	assertEquals("1405139663000", Long.toString(interpreter.getCommandAndPara().getParameters().getRemindTime().getTimeInMillis()));
	assertEquals("1", interpreter.getCommandAndPara().getParameters().getPriority());
	assertEquals("new location", interpreter.getCommandAndPara().getParameters().getLocation());
	assertEquals("default", interpreter.getCommandAndPara().getParameters().getFolder());
	assertEquals(false, interpreter.isFloatingTask());
	
    }
    
    private void handleExceptions() {
	
	// Command: utter gibberish
	try {
	    interpreter.processUserInput("bjad akwjdn");
	} catch (Exception e) {
	    assertEquals(INVALID_COMMAND_TYPE, e.getMessage());
	}
	
	testGuiTaskId();
	
	// Invalid start time:
	try {
	    interpreter.processUserInput("add hahaha -start akwdawdakwd awk");
	} catch (Exception e) {
	    assertEquals(INVALID_START_TIME, e.getMessage());
	}
	
	// Invalid end time:
	try {
	    interpreter.processUserInput("add hahaha -end akwdawdakwd awk");
	} catch (Exception e) {
	    assertEquals(INVALID_END_TIME, e.getMessage());
	}
	
	// Invalid start & time not in chronological order:
	try {
	    interpreter.processUserInput("add hahaha -start 15 july 2014 12:34:23 -end 10 july 2014 12:34:23");
	} catch (Exception e) {
	    assertEquals(EXCEPTION_END_TIME_BEFORE_START_TIME, e.getMessage());
	}
	
	// Invalid remind time:
	try {
	    interpreter.processUserInput("add hahaha -pri med -remind akwdawdakwd awk");
	} catch (Exception e) {
	    assertEquals(INVALID_REMINDER_TIME, e.getMessage());
	}
	
	// Invalid location:
	try {
	    interpreter.processUserInput("add hahaha -loc -folder tues");
	} catch (Exception e) {
	    assertEquals(EXCEPTION_EMPTY_ARGUMENT, e.getMessage());
	}
	
	// Invalid priority:
	try {
	    interpreter.processUserInput("add hahaha -pri nones");
	} catch (Exception e) {
	    assertEquals(INVALID_PRIORITY_REF, e.getMessage());
	}
	
	// Invalid folder:
	try {
	    interpreter.processUserInput("add hahaha -folder kjnad");
	} catch (Exception e) {
	    assertEquals(INVALID_FOLDER_REF, e.getMessage());
	}
	
	// Id not specified:
	try {
	    interpreter.processUserInput("mark tues -pri high");
	} catch (Exception e) {
	    assertEquals(EXCEPTION_ID_NOT_SPECIFIED, e.getMessage());
	}
	
	// Invalid parameter type:
	try {
	    interpreter.processUserInput("mark tues -awd awdnkj -ankjd");
	} catch (Exception e) {
	    assertEquals(INVALID_PARAMETER_TYPE, e.getMessage());
	}
	
	// Description cannot be empty for some commands:
	try {
	    interpreter.processUserInput("add -start tues");
	} catch (Exception e) {
	    assertEquals(INVALID_COMMAND_ARGUMENT, e.getMessage());
	}
	
    }

    private void testGuiTaskId() {
	//(when GUI is using interpreter). Note: GUI ID will always be greater than 0
	
	Interpreter.setIsGuiIdEnabled(true);
	
	Interpreter.addGuiId(2, 15); //Map guiId '2' to real task ID '15
	Interpreter.addGuiId(6, 15);

	interpreter.processUserInput("modify task -id 6 -pri low"); // No exception is raised because 6 is mapped to 15 on the GuiId list
	assertEquals("15", interpreter.getCommandAndPara().getParameters().getTaskId());
	
	try {
	    interpreter.processUserInput("modify task -id 5");
	} catch (Exception e) {
	    assertEquals(INVALID_TASK_ID, e.getMessage());
	}
	
	Interpreter.setIsGuiIdEnabled(false);
    }
    
    private void checkDefaultKeywords() {
	
	// NOTE: the following keyword strings will be invalid if the Config.cfg file is edited

	// Commands:
	assertEquals(CommandType.ADD, interpreter.interpretCommand(interpreter.getDefaultCommandSyn(CommandType.ADD)));
	assertEquals(CommandType.DELETE, interpreter.interpretCommand(interpreter.getDefaultCommandSyn(CommandType.DELETE)));
	assertEquals(CommandType.MODIFY, interpreter.interpretCommand(interpreter.getDefaultCommandSyn(CommandType.MODIFY)));
	assertEquals(CommandType.UNMARK, interpreter.interpretCommand(interpreter.getDefaultCommandSyn(CommandType.UNMARK)));
	assertEquals(CommandType.DELETE_ALL_COMPLETED, interpreter.interpretCommand(interpreter.getDefaultCommandSyn(CommandType.DELETE_ALL_COMPLETED)));
	assertEquals(CommandType.CLEAR, interpreter.interpretCommand(interpreter.getDefaultCommandSyn(CommandType.CLEAR)));
	assertEquals(CommandType.SEARCH, interpreter.interpretCommand(interpreter.getDefaultCommandSyn(CommandType.SEARCH)));
	assertEquals(CommandType.DISPLAY_NOW, interpreter.interpretCommand(interpreter.getDefaultCommandSyn(CommandType.DISPLAY_NOW)));
	assertEquals(CommandType.DISPLAY_TODAY, interpreter.interpretCommand(interpreter.getDefaultCommandSyn(CommandType.DISPLAY_TODAY)));
	assertEquals(CommandType.DISPLAY_TOMORROW, interpreter.interpretCommand(interpreter.getDefaultCommandSyn(CommandType.DISPLAY_TOMORROW)));
	assertEquals(CommandType.DISPLAY_ALL, interpreter.interpretCommand(interpreter.getDefaultCommandSyn(CommandType.DISPLAY_ALL)));
	assertEquals(CommandType.DISPLAY_ALL_FLOAT, interpreter.interpretCommand(interpreter.getDefaultCommandSyn(CommandType.DISPLAY_ALL_FLOAT)));
	assertEquals(CommandType.DISPLAY_IN_TIME, interpreter.interpretCommand(interpreter.getDefaultCommandSyn(CommandType.DISPLAY_IN_TIME)));
	assertEquals(CommandType.DISPLAY_WEEK, interpreter.interpretCommand(interpreter.getDefaultCommandSyn(CommandType.DISPLAY_WEEK)));
	assertEquals(CommandType.DISPLAY_MONTH, interpreter.interpretCommand(interpreter.getDefaultCommandSyn(CommandType.DISPLAY_MONTH)));
	assertEquals(CommandType.UNDO, interpreter.interpretCommand(interpreter.getDefaultCommandSyn(CommandType.UNDO)));
	assertEquals(CommandType.REDO, interpreter.interpretCommand(interpreter.getDefaultCommandSyn(CommandType.REDO)));
	assertEquals(CommandType.EXPORT, interpreter.interpretCommand(interpreter.getDefaultCommandSyn(CommandType.EXPORT)));
	assertEquals(CommandType.QUIT, interpreter.interpretCommand(interpreter.getDefaultCommandSyn(CommandType.QUIT)));

	// Parameters:
	assertEquals(ParameterType.START_TIME, interpreter.interpretParameter(interpreter.getDefaultParaSyn(ParameterType.START_TIME)));
	assertEquals(ParameterType.END_TIME, interpreter.interpretParameter(interpreter.getDefaultParaSyn(ParameterType.END_TIME)));
	assertEquals(ParameterType.REMINDER_TIME, interpreter.interpretParameter(interpreter.getDefaultParaSyn(ParameterType.REMINDER_TIME)));
	assertEquals(ParameterType.LOCATION, interpreter.interpretParameter(interpreter.getDefaultParaSyn(ParameterType.LOCATION)));
	assertEquals(ParameterType.FOLDER, interpreter.interpretParameter(interpreter.getDefaultParaSyn(ParameterType.FOLDER)));
	assertEquals(ParameterType.TASK_ID, interpreter.interpretParameter(interpreter.getDefaultParaSyn(ParameterType.TASK_ID)));
	
    }
    
    @Test 
    public void testOtherInterpreterConstructors() {
	
	// Re-build database from given 'Property' file
	interpreter = new Interpreter(new Config().getConfigFile());
	
	// Carry out all the test above (again):
	testDatabase();	
	testMultipleInstances();
	testTokenization();
	
	
	// Re-build database by reading the Config file again:
	interpreter = new Interpreter(true);
	
	// Carry out all the test above (again):
	testDatabase();	
	testMultipleInstances();
	testTokenization();
	
    }
}

	// End of segment: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\interpreter\InterpreterTest.java





	/**
	 * origin: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\interpreter\Parameters.java
	 */

public class Parameters {
    
    private static final int SMALLEST_ID_REFERENCE = 0;
    private static final int EXCEPTION_INVALID_ID = -1;
    private static final int FIRST_DATE_PARSED = 0;
    
    private static final String STRING_DEFAULT = "default";
    private static final String STRING_NULL = "null";
    
    private static final int PRIORITY_NONE = 0;
    private static final int PRIORITY_HIGH = 1;
    private static final int PRIORITY_MEDIUM = 2;
    private static final int PRIORITY_LOW = 3;
    private static final int PRIORITY_INVALID_REF = -1;
    
    private static Config cfg = new Config(); 
    
    private String description, location, folder;
    private Integer priority, taskId, guiIdRef = -1;
    private Calendar startTime, endTime, remindTime, recurEndTime;
    
    Parser parser;    

    public Parameters() {
	parser = new Parser(); 
    }
    
    public static Calendar dateToCal(Date date){ 
	  Calendar cal = Calendar.getInstance();
	  
	  if (date == null) {
	      return null;
	  }
	  
	  cal.setTime(date);
	  return cal;
    }
  
    public CommandFeedback setStartTime (String rawInput) {
	List<DateGroup> groups = parser.parse(rawInput);
	
	if (groups.isEmpty()) {
	    return CommandFeedback.INVALID_START_TIME;
	} 
	
	startTime = dateToCal(groups.get(FIRST_DATE_PARSED).getDates().get(FIRST_DATE_PARSED));
        
        return CommandFeedback.SUCCESSFUL_OPERATION;
    }
    
    public CommandFeedback setEndTime (String rawInput) {
	List<DateGroup> groups = parser.parse(rawInput);
	
	if (groups.isEmpty()) {
	    return CommandFeedback.INVALID_END_TIME;
	} 
	
	endTime = dateToCal(groups.get(FIRST_DATE_PARSED).getDates().get(FIRST_DATE_PARSED));
	
        return CommandFeedback.SUCCESSFUL_OPERATION;
    }
    
    public CommandFeedback setRemindTime (String rawInput) {
	List<DateGroup> groups = parser.parse(rawInput);
	
	if (groups.isEmpty()) {
	    return CommandFeedback.INVALID_REMIND_TIME;
	} 
	
	remindTime = dateToCal(groups.get(FIRST_DATE_PARSED).getDates().get(FIRST_DATE_PARSED));

	if (groups.get(FIRST_DATE_PARSED).isRecurring()) { // Note: Recurring reminders are not supported by Logic (yet)
	    recurEndTime = dateToCal(groups.get(FIRST_DATE_PARSED).getRecursUntil());
	}
        
        return CommandFeedback.SUCCESSFUL_OPERATION;
    }
    
    public CommandFeedback setDescription(String description) { 
        if (description.isEmpty() || description == null) {
            return CommandFeedback.EMPTY_DESCRIPTION;
        }
        
        this.description = description;
        return CommandFeedback.SUCCESSFUL_OPERATION;
    }
    
    public CommandFeedback setLocation(String location) {
        if (location.isEmpty() || location == null) {
            return CommandFeedback.EMPTY_LOCATION;
        }
        
        this.location = location;
        return CommandFeedback.SUCCESSFUL_OPERATION;
    }
    
    public CommandFeedback setPriority(String priority) {
        int intPriority = stringToIntPriority(priority);
        
        if (intPriority == PRIORITY_INVALID_REF) {
            return CommandFeedback.INVALID_PRIORITY;
        }
        
        this.priority = intPriority;
        return CommandFeedback.SUCCESSFUL_OPERATION;    
    }
    
    public CommandFeedback setFolder(String folder) {
        if (!isValidFolder(folder)) {
            return CommandFeedback.INVALID_FOLDER_REF;
        }
        
        this.folder = folder.toLowerCase();
        return CommandFeedback.SUCCESSFUL_OPERATION;
    }
    
    public CommandFeedback setTaskId(int id) {
	
        if (!isValidId(id)) {
            return CommandFeedback.INVALID_TASK_ID;
        }
	
        if (Interpreter.checkIsGuiIdEnabled()) {
            this.taskId = Interpreter.getRealId(id);
            this.guiIdRef = id;
        } else {
            this.taskId = id;
        }
        
        return CommandFeedback.SUCCESSFUL_OPERATION;
    }
    
    
    public int getGuiIdRef(){
	return guiIdRef;
    }
    
    public Calendar getStartTime() {
        return startTime;
    }
    
    public Calendar getEndTime() {
        return endTime;
    }
    
    public Calendar getRemindTime() {
        return remindTime;
    }
    
    public Calendar getRecurEndTime() {
	return recurEndTime;
    }
    
    public String getDescription() {
        return description;
    }
    
    public String getLocation() {
        return location;
    }
    
    public String getFolder() {
        return folder;
    }
    
    public String getPriority() {
        if (priority == null) {
            return STRING_NULL;
        }
        
        return Integer.toString(priority);
    }
    
    public String getTaskId() {
        if (taskId == null) {
            return STRING_NULL;
        }
        
        return Integer.toString(taskId);
    }
    
    
    private boolean isValidFolder(String folderName) {
	if (folderName.toLowerCase().equalsIgnoreCase(STRING_DEFAULT)) {
	    return true;
	} else if (cfg.getFolderId(folderName.toLowerCase()) != null) {
	    return true;
	}
	
        return false;
    }
    
    private boolean isValidId(int id) {
	
	if (Interpreter.checkIsGuiIdEnabled() && Interpreter.getRealId(id) != EXCEPTION_INVALID_ID) {
	    return true;
	} else if (!Interpreter.checkIsGuiIdEnabled() && id >= SMALLEST_ID_REFERENCE) {
	    return true;
	}
	
	return false;
    }
    
    private int stringToIntPriority(String priorityString) {
        if (isHigh(priorityString)) {
            return PRIORITY_HIGH;
        } else if (isMed(priorityString) ) {
            return PRIORITY_MEDIUM;
        } else if (isLow(priorityString)) {
            return PRIORITY_LOW;
        } else if (isNoneAssigned(priorityString)) {
            return PRIORITY_NONE;
        }
        
        return PRIORITY_INVALID_REF;
    }

    public boolean isNoneAssigned(String priorityString) {
	return priorityString.equalsIgnoreCase("none") || priorityString.equalsIgnoreCase("remove") || priorityString.equalsIgnoreCase("nothing") || priorityString.equalsIgnoreCase("0");
    }

    public boolean isLow(String priorityString) {
	return priorityString.equalsIgnoreCase("LOW") || priorityString.equalsIgnoreCase("not imp") || priorityString.equalsIgnoreCase("L") || priorityString.equalsIgnoreCase("3");
    }

    public boolean isMed(String priorityString) {
	return priorityString.equalsIgnoreCase("MEDIUM") || priorityString.equalsIgnoreCase("MED") || priorityString.equalsIgnoreCase("M") || priorityString.equalsIgnoreCase("2");
    }

    public boolean isHigh(String priorityString) {
	return priorityString.equalsIgnoreCase("HIGH") || priorityString.equalsIgnoreCase("H") || priorityString.equalsIgnoreCase("imp") || priorityString.equalsIgnoreCase("important") || priorityString.equalsIgnoreCase("1");
    }
    
}
	// End of segment: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\interpreter\Parameters.java





	/**
	 * origin: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\interpreter\ParameterType.java
	 */

public enum ParameterType {
    START_TIME, END_TIME, REMINDER_TIME, PRIORITY, LOCATION, FOLDER, TASK_ID,
    
    INVALID
}

	// End of segment: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\interpreter\ParameterType.java





	/**
	 * origin: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\io\Exporter.java
	 */

public class Exporter {
    
    private static final String DEFAULT_OUTPUT_FILENAME = "TASCA_Export.ics";
    private static final String MESSAGE_WRITING_FAILED = "Could not write ics file";
    private static final String MESSAGE_UID_GENERATION_FAILED = "Could not generate UID Reference";
    
    public final static Logger logger = Controller.getLogger();
    
    private static final String INFO_EXPORT_FROM_GUI = "Export initiated from GUI file finder interface";
    private static final String INFO_EXPORT_FROM_COMMAND_LINE = "Exporting initated from input bar";
    private static final String FILETYPE_ICS = ".ics";
    
    private static final String PROPERTY_PROD_ID = "-//Ben Fortuna//iCal4j 1.0//EN";
    private static final String FILEPATH_BACKSLASH = "/";
    private static final String EXCEPTION_LOCATION_NOT_SPECIFIED = "NIL";
    private static final String CONSTANT_UID_REF = "1";
    private static final String ERROR_ALL_FLOATING_TASKS = ".ics files are not used for storing ONLY floating tasks";

    private static String exportFileName = DEFAULT_OUTPUT_FILENAME;

    private static final int EMPTY_PRIORITY_REF = 0;
    private static final int EMPTY_LIST = 0;
    private static final int INVALID_PRIORITY_REF = -1;

    private static final int PRIORITY_HIGH = 1;
    private static final int PRIORITY_MEDIUM = 2;
    private static final int PRIORITY_LOW = 3;

    private static Controller controller;

    /*
     * For command line input
     */

    public Exporter(String savePath) {
	logger.log(Level.INFO, INFO_EXPORT_FROM_COMMAND_LINE);
	
	exportFileName = DEFAULT_OUTPUT_FILENAME;
	controller = new Controller();
	exportToIcs(savePath);
    }

    /*
     *  To be used by the GUI save dialog
     */

    public Exporter(String savePath, String fileName, Controller controller) {
	logger.log(Level.INFO, INFO_EXPORT_FROM_GUI);
	
	exportFileName = fileName + FILETYPE_ICS;
	Exporter.controller = controller;
	exportToIcs(savePath);
    }

    private static VEvent extractCalEvent(java.util.Calendar startTime, String description) {
	// initialise as an all-day event
	VEvent newEvent = new VEvent(new DateTime(startTime.getTime()), description);

	generateUid(newEvent);
	return newEvent;
    }

    private static VEvent extractCalEvent(java.util.Calendar startTime, java.util.Calendar endTime, String description) {
	// initialise non-all-day event
	VEvent newEvent = new VEvent(new DateTime(startTime.getTime()), new DateTime(endTime.getTime()), description);

	generateUid(newEvent);
	return newEvent;
    }

    public static void generateUid(VEvent newEvent) {
	UidGenerator ug = null;
	try {
	    ug = new UidGenerator(CONSTANT_UID_REF);
	} catch (SocketException e1) {
	    logger.log(Level.SEVERE, MESSAGE_UID_GENERATION_FAILED + e1.getStackTrace());
	}
	newEvent.getProperties().add(ug.generateUid());
    }

    private static VEvent addOtherProperties(VEvent newEvent, Task newTask, java.util.Calendar reminderTime)
    {
	if (!newTask.getLocation().equals(EXCEPTION_LOCATION_NOT_SPECIFIED)) {
	    newEvent.getProperties().add(new Location(newTask.getLocation()));
	}

	if (newTask.getPriority() != INVALID_PRIORITY_REF || newTask.getPriority() != EMPTY_PRIORITY_REF) {
	    extractAndParsePriority(newEvent, newTask);
	}

	if (newTask.getIsThereReminder()) {
	    extractAndParseReminder(newEvent, newTask, reminderTime);
	}

	return newEvent;
    }

    public static void extractAndParseReminder(VEvent newEvent, Task newTask,
	    java.util.Calendar reminderTime) {
	VAlarm reminder = new VAlarm(new DateTime(reminderTime.getTime()));
	reminder.getProperties().add(Action.DISPLAY);
	reminder.getProperties().add(new Description(newTask.getTaskTitle()));

	newEvent.getAlarms().add(reminder);
    }

    public static void extractAndParsePriority(VEvent newEvent, Task newTask) {
	int priority = newTask.getPriority();

	if (priority == PRIORITY_HIGH) {
	    newEvent.getProperties().add(new Priority(PRIORITY_HIGH));
	} else if (priority == PRIORITY_MEDIUM) {
	    newEvent.getProperties().add(new Priority(PRIORITY_MEDIUM));
	} else if (priority == PRIORITY_LOW) {
	    newEvent.getProperties().add(new Priority(PRIORITY_LOW));
	}
    }

    private static void exportToIcs(String savePath) throws InvalidParameterException {
	net.fortuna.ical4j.model.Calendar exportCal = readAndParseCurrentState();
	writeIcsFile(savePath, exportCal);
    }

    public static net.fortuna.ical4j.model.Calendar readAndParseCurrentState() {
	net.fortuna.ical4j.model.Calendar exportCal = initializeCalExporter();
	LinkedList<TaskWithReminder> timedTask = controller.getCurrentSystemState().getTimedList();

	int noOfTimedTasks = EMPTY_LIST;

	noOfTimedTasks = calToEvent(exportCal, timedTask, noOfTimedTasks);

	checkIfAllFloatingTasks(noOfTimedTasks);

	return exportCal;
    }

    public static void checkIfAllFloatingTasks(int timedTaskCounter) {
	if (timedTaskCounter == EMPTY_LIST) {
	    throw new InvalidParameterException(ERROR_ALL_FLOATING_TASKS);
	}
    }

    public static void writeIcsFile(String savePath,
	    net.fortuna.ical4j.model.Calendar exportCal) {
	String outputPath;
	if (savePath == null) {
	    outputPath = exportFileName;
	} else {
	    outputPath = savePath + FILEPATH_BACKSLASH + exportFileName; 
	}

	FileOutputStream fout = null;
	try {
	    fout = new FileOutputStream(outputPath);
	} catch (FileNotFoundException e) {
	    logger.log(Level.SEVERE, MESSAGE_WRITING_FAILED + e.getStackTrace());
	}

	CalendarOutputter outputter = new CalendarOutputter();

	try {
	    outputter.output(exportCal, fout);
	} catch (IOException | ValidationException e) {
	    logger.log(Level.SEVERE, MESSAGE_WRITING_FAILED + e.getStackTrace());
	}
    }

    public static int calToEvent(net.fortuna.ical4j.model.Calendar exportCal,
	    LinkedList<TaskWithReminder> allTimedTasks, int noOfTimedTasks) {
	
	for (int i=0; i<allTimedTasks.size(); i++) {
	    noOfTimedTasks = addNewEvent(exportCal, allTimedTasks, noOfTimedTasks, i);	  
	}
	
	return noOfTimedTasks;
    }

    public static int addNewEvent(net.fortuna.ical4j.model.Calendar exportCal,
	    LinkedList<TaskWithReminder> allTimedTasks, int noOfTimedTasks, int i) {
	Task newTask = allTimedTasks.get(i).getTask();
	VEvent newEvent;

	assert (newTask.getStartTime() != null && newTask.getEndTime() != null);

	newEvent = addTimeProperties(newTask);
	newEvent = addOtherProperties(newEvent, newTask, allTimedTasks.get(i).getReminderTime());

	noOfTimedTasks++;
	exportCal.getComponents().add(newEvent);
	
	return noOfTimedTasks;
    }

    public static VEvent addTimeProperties(Task newTask) {
	VEvent newEvent;
	if (newTask.getIsAllDayEvent()) {
	    newEvent = extractCalEvent(newTask.getStartTime(), newTask.getTaskTitle());
	}

	newEvent = extractCalEvent(newTask.getStartTime(), newTask.getEndTime(), newTask.getTaskTitle());
	return newEvent;
    }

    private static net.fortuna.ical4j.model.Calendar initializeCalExporter() {
	net.fortuna.ical4j.model.Calendar ical4j = new net.fortuna.ical4j.model.Calendar();
	ical4j.getProperties().add(new ProdId(PROPERTY_PROD_ID));
	ical4j.getProperties().add(Version.VERSION_2_0);
	ical4j.getProperties().add(CalScale.GREGORIAN);
	return ical4j;
    }

}

	// End of segment: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\io\Exporter.java





	/**
	 * origin: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\io\Importer.java
	 */

public class Importer {
        
    public final static Logger logger = Controller.getLogger();
    
    private static final String MESSAGE_COULD_NOT_READ_FILE = "Could not read ICS file";
    private static final String MESSAGE_COULD_NOT_BUILD_ICS = "Could not build ics calendar";
    private static final String INFO_IMPORT_FROM_COMMAND_LINE = "Import intiated from command line input";
    private static final String INFO_IMPORT_FROM_GUI = "Impor initated from GUI file finder interface";
    
    private static final int PRIORITY_MED_REF = 2;
    private static final int PRIORITY_HIGH_REF = 1;
    
    private static final String PRIORITY_LOW = "Low";
    private static final String PRIORITY_MEDIUM = "Med";
    private static final String PRIORITY_HIGH = "High";
    
    private static final String DELIMETER_SPACED = " -";
    private static final String SINGLE_SPACE = " ";

    private static final String IDENTIFIER_LOCATION = "LOCATION:";
    private static final String IDENTIFIER_SUMMARY = "SUMMARY:";

    private static final String DEFAULT_DESCRIPTION_STRING = "No Description";
    private static final String DEFAULT_EMPTY = "";

    private static final String CONSTANT_VALUE_DATE = "VALUE=DATE";
    private static final String CONSTANT_NEW_LINE_REF = "\n";
    
    private static final String FORMAT_DATE_AND_TIME = "dd MMM yyyy HH:mm";

    private Integer priority;
    private java.util.Calendar startTime;
    private java.util.Calendar endTime;
    private java.util.Calendar remindTime;
    private java.util.Calendar recurEndTime;
    private Boolean isTaskDone;
    private Boolean isThereReminder;
    private Boolean isAllDayEvent;
    private String description;
    private String location;

    private static SimpleDateFormat dateFormatter = new SimpleDateFormat(FORMAT_DATE_AND_TIME);

    private static Controller controller;

    public Importer(String filePath) {
	logger.log(Level.INFO, INFO_IMPORT_FROM_COMMAND_LINE);
	
	controller = new Controller();
	importIcs(filePath);
    }

    public Importer(String filePath, Controller controller) {
	logger.log(Level.INFO, INFO_IMPORT_FROM_GUI);
	
	Importer.controller = controller;
	importIcs(filePath);	
    }

    private boolean isEventAllDay(VEvent event) {
	return event.getStartDate().toString().indexOf(CONSTANT_VALUE_DATE) != -1;
    }

    private void clearAllPropertyVars() {
	priority = null;
	startTime = null;
	endTime = null;
	remindTime = null;
	recurEndTime = null;
	isTaskDone = null;
	isThereReminder = null;
	isAllDayEvent = null;
	description = null;
	location = null;
    }

    private void importIcs(String filePath) {
	Calendar calendar = initializeCalParser(filePath);
	parseAndSaveItems(calendar);
    }

    public void parseAndSaveItems(Calendar calendar) {
	
	if (calendar == null) {
	    return;
	}
	
	LinkedList<String> newTaskList = new LinkedList<String>();
	
	for (@SuppressWarnings("rawtypes") // Compiler warning suppression
	Iterator i = calendar.getComponents().iterator(); i.hasNext();) {
	    VEvent newTask = (VEvent) i.next();
	    readTaskProperties(newTask);

	    VAlarm newReminder = (VAlarm) newTask.getAlarms().getComponent(Component.VALARM);
	    readReminderProperties(newReminder);	  	    

	    addItemToList(newTaskList);
	}
	
	controller.mutexAdd(newTaskList);
    }

    public void addItemToList(LinkedList<String> newTaskList) {

	Interpreter interpreter = new Interpreter();

	String description = DEFAULT_DESCRIPTION_STRING;
	String startTime = DEFAULT_EMPTY;
	String endTime = DEFAULT_EMPTY;
	String remindTime = DEFAULT_EMPTY;
	String location = DEFAULT_EMPTY;
	String priority = DEFAULT_EMPTY;

	if (this.description != null) {
	    description = SINGLE_SPACE + this.description.replaceAll(IDENTIFIER_SUMMARY, DEFAULT_EMPTY) + SINGLE_SPACE;
	}

	// Time properties: 
	if (this.endTime == null && this.startTime != null) {
	    endTime = DELIMETER_SPACED + interpreter.getDefaultParaSyn(ParameterType.END_TIME) + SINGLE_SPACE + dateFormatter.format(this.startTime.getTime());
	} else if (this.endTime != null && this.startTime == null) {
	    endTime = DELIMETER_SPACED + interpreter.getDefaultParaSyn(ParameterType.END_TIME) + SINGLE_SPACE + dateFormatter.format(this.endTime.getTime());
	} else if (this.endTime != null && this.startTime != null) {
	    startTime = DELIMETER_SPACED + interpreter.getDefaultParaSyn(ParameterType.START_TIME) + SINGLE_SPACE + dateFormatter.format(this.startTime.getTime());
	    endTime = DELIMETER_SPACED + interpreter.getDefaultParaSyn(ParameterType.END_TIME) + SINGLE_SPACE + dateFormatter.format(this.endTime.getTime());
	}

	// Other Properties:
	if (this.remindTime != null) {
	    remindTime = DELIMETER_SPACED + interpreter.getDefaultParaSyn(ParameterType.REMINDER_TIME) + SINGLE_SPACE + dateFormatter.format(this.remindTime.getTime());
	}

	if (this.location != null) {
	    location = DELIMETER_SPACED + interpreter.getDefaultParaSyn(ParameterType.LOCATION) + SINGLE_SPACE + this.location.replaceAll(IDENTIFIER_LOCATION,DEFAULT_EMPTY);
	}

	if (this.priority != null) {
	    priority = DELIMETER_SPACED + interpreter.getDefaultParaSyn(ParameterType.PRIORITY) + SINGLE_SPACE + decodePriority();
	}

	newTaskList.add(interpreter.getDefaultCommandSyn(CommandType.ADD) + SINGLE_SPACE + description + endTime + startTime + remindTime + location + priority);	
    }

    private String decodePriority() {
	if (priority == PRIORITY_HIGH_REF) {
	    return PRIORITY_HIGH;
	} else if (priority == PRIORITY_MED_REF) {
	    return PRIORITY_MEDIUM;
	} else {
	    return PRIORITY_LOW;
	}

    }

    public void readReminderProperties(VAlarm newReminder) {
	if (newReminder != null) {
	    isThereReminder = true;
	    remindTime = Parameters.dateToCal(newReminder.getTrigger().getDateTime());
	} else {
	    isThereReminder = false;
	}
    }

    public void readTaskProperties(VEvent newTask) {
	Property summaryProperty = newTask.getProperty(Property.SUMMARY);
	Property locationProperty = newTask.getProperty(Property.LOCATION);
	Property priorityProperty = newTask.getProperty(Property.PRIORITY);
	Property startTimeProperty = newTask.getProperty(Property.DTSTART);
	Property endTimeProperty = newTask.getProperty(Property.DTEND);
	Property isTaskDoneProperty = newTask.getProperty(Property.COMPLETED);

	clearAllPropertyVars();


	readTimeProperties(newTask, startTimeProperty, endTimeProperty);

	readOtherProperties(summaryProperty, locationProperty,
		priorityProperty, isTaskDoneProperty);


	isAllDayEvent = isEventAllDay(newTask);
    }

    public void readOtherProperties(Property summaryProperty,
	    Property locationProperty, Property priorityProperty,
	    Property isTaskDoneProperty) {
	if (summaryProperty != null) {
	    description = summaryProperty.toString().replace(CONSTANT_NEW_LINE_REF, DEFAULT_EMPTY); // remove new line from string
	}

	if (locationProperty != null) {
	    location = locationProperty.toString().replace(CONSTANT_NEW_LINE_REF, DEFAULT_EMPTY);
	}

	if (priorityProperty != null) {
	    priority = Integer.parseInt(priorityProperty.toString().substring(9,10)); // 9th character contains the actual priority num reference according to ICS file standards
	}

	if (isTaskDoneProperty != null) {
	    isTaskDone = true;
	} else {
	    isTaskDone = false;
	}
    }

    public void readTimeProperties(VEvent newTask, Property startTimeProperty,
	    Property endTimeProperty) {
	if (startTimeProperty != null) {
	    startTime = Parameters.dateToCal(new DateTime(newTask.getStartDate().getDate()));
	}

	if (endTimeProperty != null) {
	    endTime = Parameters.dateToCal(new DateTime(newTask.getEndDate().getDate()));
	}
    }

    public Calendar initializeCalParser(String filePath) {
	FileInputStream fin = null;

	try {
	    fin = new FileInputStream(filePath);
	} catch (FileNotFoundException e) {
	    logger.log(Level.SEVERE, MESSAGE_COULD_NOT_READ_FILE + e.getStackTrace());
	}

	CalendarBuilder builder = new CalendarBuilder();

	Calendar calendar = null;
	try {
	    calendar = builder.build(fin);
	} catch (IOException | ParserException e) {
	    logger.log(Level.SEVERE, MESSAGE_COULD_NOT_BUILD_ICS + e.getStackTrace());
	}
	return calendar;
    }


}

	// End of segment: Z:\Desktop\NUS\SEM4\CS1231\TASCA\Tasca\src\io\Importer.java





